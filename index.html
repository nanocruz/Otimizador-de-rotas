<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Otimizador de Rotas</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<script src="https://serratus.github.io/quaggaJS/dist/quagga.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #f5f5f5; color: #333; min-height: 100vh; padding: 20px; padding-bottom: 120px; display: flex; flex-direction: column; align-items: center; }
.container { max-width: 100%; width: 100%; margin: 0 auto; padding: 0 10px; }
.header { text-align: center; color: white; margin-bottom: 20px; background: #0056b3; padding: 15px 20px; border-radius: 10px 10px 0 0; }
.header h1 { font-size: 28px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; gap: 10px; }
.card { background: white; border: 1px solid #ddd; border-radius: 10px; padding: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); margin-bottom: 20px; }
.status-bar { padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 14px; }
.status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
.status-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
.status-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
.tip-box { background: #e3f2fd; border-left: 4px solid #0056b3; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
.tip-box strong { display: block; margin-bottom: 5px; color: #0056b3; }
.tip-box small { display: block; margin-top: 8px; font-size: 12px; color: #555; }
.input-group { display: flex; gap: 10px; margin-bottom: 15px; }
input[type="text"] { flex: 1; padding: 15px; border: 1px solid #ccc; border-radius: 8px; font-size: 16px; }
input[type="text"]:focus { outline: none; border-color: #0056b3; box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.1); }
.btn { padding: 15px 25px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; }
.btn-primary { background: #0056b3; color: white; }
.btn-primary:hover { background: #004494; }
.btn-voice { background: #e9ecef; color: #333; flex: 1; }
.btn-voice.listening { background: #ef5350; color: white; animation: pulse 1.5s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
.btn-optimize { position: fixed; bottom: 20px; left: 20px; right: 20px; width: auto; background: #0056b3; color: white; font-size: 18px; padding: 18px; box-shadow: 0 4px 12px rgba(0, 86, 179, 0.2); z-index: 1000; }
.btn-optimize:disabled { opacity: 0.6; cursor: not-allowed; }
.spinner { border: 2px solid rgba(255, 255, 255, 0.3); border-top: 2px solid white; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; display: inline-block; }
@keyframes spin { to { transform: rotate(360deg); } }
.btn-small { padding: 10px 15px; font-size: 14px; }
.buttons-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 10px; margin-bottom: 20px; }
.address-list { margin-bottom: 20px; }
.address-item { display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border: 1px solid #eee; border-radius: 8px; margin-bottom: 10px; cursor: default; }
.address-number { background: #0056b3; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
.address-text { flex: 1; font-size: 14px; }
.btn-delete { background: #ff5252; color: white; width: 35px; height: 35px; border-radius: 6px; border: none; cursor: pointer; flex-shrink: 0; }
.route-item { padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #ddd; }
.route-item.active { background: #cce5ff; border-color: #0056b3; box-shadow: 0 2px 8px rgba(0, 86, 179, 0.1); }
.route-item.completed { background: #e8f5e9; border-color: #4caf50; }
.route-header { display: flex; align-items: flex-start; gap: 10px; margin-bottom: 15px; }
.route-number { width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
.route-number.active { background: #0056b3; color: white; }
.route-number.completed { background: #4caf50; color: white; }
.route-text { flex: 1; }
.route-text strong { display: block; margin-bottom: 5px; font-size: 16px; }
.route-text small { color: #666; font-size: 13px; }
.route-buttons { display: grid; grid-template-columns: 1fr 1fr auto; gap: 8px; }
.btn-maps { background: #007bff; color: white; }
.btn-waze { background: #00d9ff; color: white; }
.btn-complete { background: #4caf50; color: white; width: 45px; }
.progress-bar { background: #e8eaf6; padding: 15px; border-radius: 8px; text-align: center; margin-top: 20px; }
.progress-bar strong { color: #0056b3; font-size: 18px; }
#camera-container { margin-bottom: 20px; }
#camera-video { width: 100%; border-radius: 8px; margin-bottom: 10px; }
.camera-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.btn-capture { background: #4caf50; color: white; }
.btn-cancel { background: #f44336; color: white; }
.header-actions { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
.btn-reset { background: #f44336; color: white; }
.base-location-section { background: #fff8e1; border: 1px dashed #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px; }
.base-location-display { font-size: 14px; color: #555; text-align: center; margin-top: 10px; }
.suggestion-item { background: #f0f8ff !important; cursor: pointer; }
.suggestion-item:hover { background: #e3f2fd !important; }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>
      <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>
      </svg>
      Otimizador de Rotas
    </h1>
  </div>
  <div id="status-container"></div>
  <div id="base-location-section" class="card base-location-section">
    <h3 style="margin-bottom: 10px; color: #333;">Localiza√ß√£o Base</h3>
    <p style="margin-bottom: 15px; font-size: 14px; color: #555;">Defina a cidade/regi√£o onde voc√™ deseja adicionar os endere√ßos.</p>
    <div class="base-location-input-group">
      <input type="text" id="base-location-input" placeholder="Ex: S√£o Paulo, SP" />
      <button class="btn btn-primary" style="padding:12px 16px; font-size:16px;" onclick="setBaseLocation()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </button>
    </div>
    <div id="base-location-display" class="base-location-display">
      Nenhuma localiza√ß√£o base definida. Por favor, defina para continuar.
    </div>
  </div>
  <div id="departure-section" class="card" style="display: none;">
    <h3 style="margin-bottom: 10px; color: #333;">Ponto de Partida</h3>
    <p style="margin-bottom: 15px; font-size: 14px; color: #555;">De onde voc√™ vai iniciar a rota?</p>
    <div class="input-group">
      <input type="text" id="departure-input" placeholder="Ex: Av. Paulista, 1000 ou 01310-100, 1000" />
      <button class="btn btn-primary" onclick="setDepartureAddress()">+</button>
    </div>
    <div id="departure-suggestions" class="address-list" style="display: none;"></div>
    <button class="btn btn-voice" style="width:100%; margin-top:10px;" onclick="setDepartureCurrentLocation()">
      Usar Minha Localiza√ß√£o Atual
    </button>
    <div id="departure-display" class="base-location-display" style="margin-top:10px;">
      Nenhum ponto de partida definido.
    </div>
  </div>
  <div id="add-section" class="card">
    <h2 style="margin-bottom: 15px; color: #333;">Adicionar Endere√ßos</h2>
    <div class="tip-box">
      <strong>Dica de uso:</strong>
      Use endere√ßos completos ou CEP para melhores resultados!
      <small>Exemplos: "Av. Paulista, 1578, S√£o Paulo, SP" ‚Ä¢ "85855-185" ‚Ä¢ "85855185, 555" ‚Ä¢ "CEP: 85855-185"</small>
    </div>
    <div class="input-group">
      <input type="text" id="address-input" placeholder="Ex: Av. Paulista, 1578 ou CEP 01310-100" />
      <button class="btn btn-primary" onclick="addAddress()">+</button>
    </div>
    <div class="buttons-grid">
      <button class="btn btn-voice" id="voice-btn" onclick="requestVoicePermissionAndStart()">Voz</button>
      <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('photo')">Foto</button>
      <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('barcode')">C√≥digo</button>
      <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('qr')">QR</button>
      <button class="btn btn-voice" onclick="addUserLocationManually()">Minha Posi√ß√£o</button>
      <button class="btn btn-voice" onclick="uploadPdf()">PDF</button>
    </div>
    <div id="camera-container" style="display: none;">
      <video id="camera-video" autoplay playsinline></video>
      <div class="camera-buttons" id="camera-buttons"></div>
    </div>
    <div id="address-list" class="address-list"></div>
    <div id="suggestions-container" class="address-list" style="display: none;"></div>
  </div>
  <div id="route-section" class="card" style="display: none;">
    <div class="header-actions">
      <h2 style="color: #333;">Rota Otimizada</h2>
      <button class="btn btn-reset btn-small" onclick="resetRoute()">Reiniciar</button>
    </div>
    <div id="route-list"></div>
    <div id="progress-bar" class="progress-bar"></div>
  </div>
  <button id="optimize-btn" class="btn btn-optimize" onclick="optimizeRoute()" style="display: none;">
    Otimizar Rota
  </button>
  <input type="file" id="pdf-upload" accept=".pdf" style="display:none;" onchange="processPdf(event)">
</div>
<script>
let addresses = [];
let optimizedRoute = [];
let activeIndex = 0;
let userLocation = null;
let departure = null;
let isListening = false;
let cameraStream = null;
let scannerType = null;
let isPhotoMode = false;
let distanceCache = new Map();

function getCacheKey(lat1, lon1, lat2, lon2) {
  const p1 = `${lat1.toFixed(6)},${lon1.toFixed(6)}`;
  const p2 = `${lat2.toFixed(6)},${lon2.toFixed(6)}`;
  return p1 < p2 ? `${p1}|${p2}` : `${p2}|${p1}`;
}

window.onload = () => {
  document.getElementById('address-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') addAddress(); });
  document.getElementById('base-location-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); setBaseLocation(); } });
  document.getElementById('departure-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') setDepartureAddress(); });
  if (window.pdfjsLib) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  }
};

// üîπ FUN√á√ÉO DE DELAY PARA EVITAR ERRO 429
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function geocodeBasic(address, retryCount = 0) {
  try {
    // Adiciona um pequeno delay entre requisi√ß√µes para evitar 429
    await sleep(1000); 
    
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1&accept-language=pt-BR`;
    const resp = await fetch(url, { 
      headers: { 
        'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)',
        'Accept': 'application/json'
      } 
    });

    if (resp.status === 429 && retryCount < 3) {
      console.warn(`Erro 429 detectado. Tentando novamente em ${2000 * (retryCount + 1)}ms...`);
      await sleep(2000 * (retryCount + 1));
      return geocodeBasic(address, retryCount + 1);
    }

    if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);

    const data = await resp.json();
    if (data?.length > 0) {
      return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), display_name: data[0].display_name };
    }
  } catch (e) { 
    console.error('Erro na geocodifica√ß√£o:', e); 
    if (retryCount < 2) {
      await sleep(2000);
      return geocodeBasic(address, retryCount + 1);
    }
  }
  return null;
}

async function processCEP(text) {
  const cepMatch = text.match(/(?:cep\s*:?\s*)?(\d{5})-?(\d{3})(?:\s*,?\s*(\d+))?/i);
  if (!cepMatch) return null;
  const cep = cepMatch[1] + cepMatch[2];
  const numero = cepMatch[3] || '';
  showStatus('Buscando CEP...', 'info');
  try {
    const resp = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
    const data = await resp.json();
    if (data.erro) throw new Error('CEP n√£o encontrado');
    let addressText = data.logradouro || '';
    if (numero) addressText += `, ${numero}`;
    if (data.bairro) addressText += `, ${data.bairro}`;
    addressText += `, ${data.localidade}, ${data.uf}`;
    let coords = await geocodeBasic(`${addressText}, Brasil`);
    if (!coords) coords = await geocodeBasic(`${cep}, Brasil`);
    if (!coords) coords = await geocodeBasic(`${data.localidade}, ${data.uf}, Brasil`);
    if (!coords) throw new Error('Coordenadas n√£o encontradas');
    showStatus('CEP encontrado!', 'success');
    return { success: true, address: addressText, coords };
  } catch (e) {
    showStatus('CEP inv√°lido: ' + e.message, 'warning');
    return { success: false };
  }
}

async function calculateRealDistance(from, to) {
  if (!from || !to || typeof from.lat !== 'number' || typeof from.lon !== 'number' || typeof to.lat !== 'number' || typeof to.lon !== 'number') {
    return { distance: Number.POSITIVE_INFINITY, duration: Number.POSITIVE_INFINITY };
  }
  const key = getCacheKey(from.lat, from.lon, to.lat, to.lon);
  if (distanceCache.has(key)) return distanceCache.get(key);
  try {
    const url = `https://routing.openstreetmap.de/routed-car/route/v1/driving/${from.lon},${from.lat};${to.lon},${to.lat}?overview=false`;
    const resp = await fetch(url, { headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' } });
    if (resp.ok) {
      const data = await resp.json();
      if (data?.code === 'Ok' && data.routes?.length > 0) {
        const result = { distance: data.routes[0].distance, duration: data.routes[0].duration };
        distanceCache.set(key, result);
        return result;
      }
    }
  } catch (err) { console.warn('Roteamento falhou, usando Haversine.', err); }
  const R = 6371000;
  const œÜ1 = from.lat * Math.PI / 180;
  const œÜ2 = to.lat * Math.PI / 180;
  const ŒîœÜ = (to.lat - from.lat) * Math.PI / 180;
  const ŒîŒª = (to.lon - from.lon) * Math.PI / 180;
  const a = Math.sin(ŒîœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c;
  const duration = distance / 13.89;
  const result = { distance, duration };
  distanceCache.set(key, result);
  return result;
}

async function optimizeRouteNearestNeighbor(start, targets) {
  let current = start;
  let unvisited = [...targets];
  let route = [];
  while (unvisited.length > 0) {
    let nearest = null;
    let minDistance = Number.POSITIVE_INFINITY;
    let nearestIndex = -1;
    for (let i = 0; i < unvisited.length; i++) {
      const { distance } = await calculateRealDistance(current.coords, unvisited[i].coords);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = unvisited[i];
        nearestIndex = i;
      }
    }
    route.push(nearest);
    current = nearest;
    unvisited.splice(nearestIndex, 1);
  }
  return route;
}

async function twoOptImprovement(route, start) {
  let improved = true;
  let bestRoute = [...route];
  async function getRouteDistance(r) {
    let total = 0;
    let prev = start.coords;
    for (const p of r) {
      const { distance } = await calculateRealDistance(prev, p.coords);
      total += distance;
      prev = p.coords;
    }
    return total;
  }
  let bestDist = await getRouteDistance(bestRoute);
  while (improved) {
    improved = false;
    for (let i = 0; i < bestRoute.length - 1; i++) {
      for (let j = i + 1; j < bestRoute.length; j++) {
        let newRoute = [...bestRoute];
        let sub = newRoute.slice(i, j + 1).reverse();
        newRoute.splice(i, sub.length, ...sub);
        let newDist = await getRouteDistance(newRoute);
        if (newDist < bestDist) {
          bestRoute = newRoute;
          bestDist = newDist;
          improved = true;
        }
      }
    }
  }
  return bestRoute;
}

async function addAddress() {
  if (!userLocation) return showStatus('Defina a localiza√ß√£o base primeiro.', 'warning');
  const input = document.getElementById('address-input');
  let text = input.value.trim();
  if (!text) return;
  showStatus('Buscando endere√ßo...', 'info');
  const cepResult = await processCEP(text);
  if (cepResult?.success) {
    if (cepResult.coords && typeof cepResult.coords.lat === 'number' && !isNaN(cepResult.coords.lat)) {
      addresses.push({ id: Date.now(), text: cepResult.address, coords: cepResult.coords, completed: false });
      input.value = '';
      renderAddressList();
      document.getElementById('optimize-btn').style.display = 'block';
      showStatus('Endere√ßo adicionado!', 'success');
      return;
    }
  }
  const fullQuery = `${text}, ${userLocation.city}, ${userLocation.state}, Brasil`;
  const coords = await geocodeBasic(fullQuery);
  if (coords && typeof coords.lat === 'number' && !isNaN(coords.lat)) {
    addresses.push({ id: Date.now(), text: text, coords: coords, completed: false });
    input.value = '';
    renderAddressList();
    document.getElementById('optimize-btn').style.display = 'block';
    showStatus('Endere√ßo adicionado!', 'success');
  } else {
    showStatus('Buscando sugest√µes...', 'info');
    await searchAndSelectAddress(text);
  }
}

async function searchAndSelectAddress(query) {
  const suggestionsContainer = document.getElementById('suggestions-container');
  suggestionsContainer.style.display = 'block';
  suggestionsContainer.innerHTML = '<div class="status-bar status-info">Buscando endere√ßos...</div>';
  try {
    const cityState = `${userLocation.city}, ${userLocation.state}, Brasil`;
    const fullQuery = `${query}, ${cityState}`;
    const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullQuery)}&limit=5&addressdetails=1&accept-language=pt-BR`, {
      headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' }
    });
    const results = await resp.json();
    if (!results || results.length === 0) {
      suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Nenhum endere√ßo encontrado.</div>';
      setTimeout(() => suggestionsContainer.style.display = 'none', 4000);
      return;
    }
    let html = '<h4 style="margin:10px 0;color:#333;">Escolha o endere√ßo correto:</h4>';
    results.forEach((res, i) => {
      const addr = res.address || {};
      const display = `${addr.road || ''}${addr.house_number ? ', ' + addr.house_number : ''} ‚Äì ${addr.suburb || addr.neighbourhood || ''}`;
      html += `<div class="address-item suggestion-item" onclick="selectSuggestion(${i})"><div>${display}</div><small>${addr.city || userLocation.city}</small></div>`;
    });
    suggestionsContainer.innerHTML = html;
    window.pendingSuggestions = results;
  } catch (e) { suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Erro na busca.</div>'; }
}

function selectSuggestion(index) {
  const result = window.pendingSuggestions?.[index];
  if (!result) return;
  const addr = result.address || {};
  let displayText = `${addr.road || ''}${addr.house_number ? ', ' + addr.house_number : ''}, ${addr.suburb || ''}, ${addr.city || ''}`;
  addresses.push({ id: Date.now(), text: displayText, coords: { lat: parseFloat(result.lat), lon: parseFloat(result.lon) }, completed: false });
  document.getElementById('address-input').value = '';
  renderAddressList();
  document.getElementById('optimize-btn').style.display = 'block';
  document.getElementById('suggestions-container').style.display = 'none';
  showStatus('Endere√ßo adicionado!', 'success');
}

function setBaseLocation() {
  const input = document.getElementById('base-location-input');
  const text = input.value.trim();
  if (!text) return showStatus('Informe cidade e estado.', 'warning');
  geocodeBaseLocation(text);
}

async function geocodeBaseLocation(locationText) {
  showStatus('Verificando localiza√ß√£o base...', 'info');
  try {
    const data = await (await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationText + ', Brasil')}&limit=1&addressdetails=1&accept-language=pt-BR`, {
      headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' }
    })).json();
    if (!data?.length) throw new Error('Nenhum resultado encontrado.');
    const addr = data[0].address || {};
    const city = addr.city || addr.town || addr.municipality || addr.village || '';
    const state = addr.state || '';
    if (!city) throw new Error('Cidade n√£o identificada.');
    userLocation = { city, state };
    document.getElementById('base-location-display').textContent = `Localiza√ß√£o base: ${city}${state ? ', ' + state : ''}.`;
    document.getElementById('departure-section').style.display = 'block';
    showStatus(`Localiza√ß√£o base definida!`, 'success');
  } catch (error) {
    showStatus(`${error.message}`, 'warning');
    userLocation = null;
  }
}

async function setDepartureAddress() {
  const input = document.getElementById('departure-input');
  const text = input.value.trim();
  if (!text) return showStatus('Informe o ponto de partida.', 'warning');
  const cepResult = await processCEP(text);
  if (cepResult?.success) {
    departure = { text: cepResult.address, coords: cepResult.coords };
    document.getElementById('departure-display').textContent = departure.text;
    input.value = '';
    showStatus('Partida definida!', 'success');
    return;
  }
  await searchAndSelectDeparture(text);
}

async function setDepartureCurrentLocation() {
  if (!navigator.geolocation) return showStatus('Geolocaliza√ß√£o n√£o suportada.', 'warning');
  showStatus('Obtendo sua localiza√ß√£o...', 'info');
  navigator.geolocation.getCurrentPosition(async (pos) => {
    const { latitude, longitude } = pos.coords;
    departure = { text: 'Minha localiza√ß√£o atual', coords: { lat: latitude, lon: longitude } };
    document.getElementById('departure-display').textContent = 'Minha localiza√ß√£o atual';
    showStatus('Partida definida!', 'success');
  }, (err) => showStatus('Erro na localiza√ß√£o: ' + err.message, 'warning'), { enableHighAccuracy: true });
}

async function searchAndSelectDeparture(query) {
  const suggestionsContainer = document.getElementById('departure-suggestions');
  suggestionsContainer.style.display = 'block';
  suggestionsContainer.innerHTML = '<div class="status-bar status-info">Buscando endere√ßos...</div>';
  try {
    const cityState = `${userLocation.city}, ${userLocation.state}, Brasil`;
    const fullQuery = `${query}, ${cityState}`;
    const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullQuery)}&limit=5&addressdetails=1&accept-language=pt-BR`, {
      headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' }
    });
    const results = await resp.json();
    if (!results || results.length === 0) {
      suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Nenhum endere√ßo encontrado.</div>';
      return;
    }
    let html = '<h4 style="margin:10px 0;color:#333;">Escolha o ponto de partida:</h4>';
    results.forEach((res, i) => {
      html += `<div class="address-item suggestion-item" onclick="selectDepartureSuggestion(${i})"><div>${res.display_name}</div></div>`;
    });
    suggestionsContainer.innerHTML = html;
    window.pendingDepartureSuggestions = results;
  } catch (e) { suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Erro na busca.</div>'; }
}

function selectDepartureSuggestion(index) {
  const result = window.pendingDepartureSuggestions?.[index];
  if (!result) return;
  departure = { text: result.display_name, coords: { lat: parseFloat(result.lat), lon: parseFloat(result.lon) } };
  document.getElementById('departure-input').value = '';
  document.getElementById('departure-display').textContent = departure.text;
  document.getElementById('departure-suggestions').style.display = 'none';
  showStatus('Partida definida!', 'success');
}

function normalizeCoords(coords) {
  if (!coords) return null;
  const lat = Number(coords.lat);
  const lon = Number(coords.lon);
  if (isNaN(lat) || isNaN(lon)) return null;
  return { lat, lon };
}

async function geocodeAddressFull(address) {
  let full = address + ', Brasil';
  if (userLocation) full = `${address}, ${userLocation.city}${userLocation.state ? ', ' + userLocation.state : ''}, Brasil`;
  let coords = await geocodeBasic(full);
  if (coords) return coords;
  if (userLocation) {
    const fallback = `${userLocation.city}, ${userLocation.state}, Brasil`;
    coords = await geocodeBasic(fallback);
    if (coords) return coords;
  }
  return null;
}

async function optimizeRoute() {
  if (!departure || addresses.length === 0) return showStatus('Defina partida e destinos.', 'warning');
  const btn = document.getElementById('optimize-btn');
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Otimizando...';
  try {
    const destinosValidos = [];
    for (let i = 0; i < addresses.length; i++) {
      const addr = addresses[i];
      showStatus(`Validando endere√ßo ${i+1} de ${addresses.length}...`, 'info');
      if (!addr.coords || !addr.coords.lat || !addr.coords.lon) {
        const coords = await geocodeAddressFull(addr.text);
        if (coords) { addr.coords = coords; destinosValidos.push(addr); }
      } else { destinosValidos.push(addr); }
    }
    if (destinosValidos.length === 0) return showStatus('Nenhum destino v√°lido.', 'warning');
    showStatus('Calculando melhor rota...', 'info');
    let optimized = await optimizeRouteNearestNeighbor(departure, destinosValidos);
    if (optimized.length > 3) optimized = await twoOptImprovement(optimized, departure);
    optimizedRoute = [{ ...departure, completed: true }, ...optimized];
    activeIndex = 1;
    document.getElementById('add-section').style.display = 'none';
    document.getElementById('route-section').style.display = 'block';
    btn.style.display = 'none';
    await renderRoute();
    showStatus('Rota otimizada!', 'success');
  } catch (e) { console.error(e); showStatus('Erro ao otimizar.', 'warning'); }
  finally { btn.disabled = false; btn.innerHTML = 'Otimizar Rota'; }
}

function renderAddressList() {
  const list = document.getElementById('address-list');
  if (addresses.length === 0) { list.innerHTML = ''; return; }
  let html = '';
  addresses.forEach((addr, i) => {
    html += `<div class="address-item">
      <div class="address-number">${i + 1}</div>
      <div class="address-text">${addr.text}</div>
      <button class="btn-delete" onclick="editAddress(${addr.id})" title="Editar">‚úèÔ∏è</button>
      <button class="btn-delete" onclick="deleteAddress(${addr.id})" title="Excluir">√ó</button>
    </div>`;
  });
  list.innerHTML = html;
}

function editAddress(id) {
  const addr = addresses.find(a => a.id === id);
  if (!addr) return;
  const newText = prompt('Editar endere√ßo:', addr.text);
  if (newText === null || newText.trim() === '') return;
  (async () => {
    showStatus('Atualizando...', 'info');
    const coords = await geocodeBasic(newText.trim());
    if (coords) { addr.text = newText.trim(); addr.coords = coords; renderAddressList(); showStatus('Atualizado!', 'success'); }
    else { showStatus('N√£o localizado.', 'warning'); }
  })();
}

async function renderRoute() {
  const list = document.getElementById('route-list');
  let html = '';
  for (let i = 0; i < optimizedRoute.length; i++) {
    const a = optimizedRoute[i];
    const ativo = i === activeIndex && !a.completed;
    const concluido = a.completed;
    let distInfo = '';
    if (i > 0) {
      const { distance, duration } = await calculateRealDistance(optimizedRoute[i - 1].coords, a.coords);
      distInfo = `<small style="color:#0056b3;">${(distance / 1000).toFixed(1)}km ¬∑ ${Math.round(duration / 60)}min</small>`;
    }
    html += `<div class="route-item ${ativo ? 'active' : ''} ${concluido ? 'completed' : ''}">
      <div class="route-header">
        <div class="route-number ${ativo ? 'active' : ''} ${concluido ? 'completed' : ''}">${concluido ? '‚úì' : i === 0 ? 'P' : i}</div>
        <div class="route-text"><strong>${i === 0 ? 'Ponto de Partida' : a.text}</strong>${distInfo}</div>
      </div>
      ${ativo && !concluido ? `<div class="route-buttons">
          <button class="btn btn-maps btn-small" onclick="openMaps(${i}, 'google')">Maps</button>
          <button class="btn btn-waze btn-small" onclick="openMaps(${i}, 'waze')">Waze</button>
          <button class="btn btn-complete btn-small" onclick="markCompleted(${i})">‚úì</button>
        </div>` : ''}
    </div>`;
  }
  list.innerHTML = html;
  updateProgress();
}

function openMaps(i, app) {
  const a = optimizedRoute[i];
  const { lat, lon } = a.coords || {};
  if (app === 'google') window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lon}`, '_blank');
  else if (app === 'waze') window.open(`https://www.waze.com/ul?ll=${lat},${lon}&navigate=yes`, '_blank');
}

function markCompleted(i) {
  optimizedRoute[i].completed = true;
  if (i < optimizedRoute.length - 1) activeIndex = i + 1;
  renderRoute();
}

function updateProgress() {
  const concluidos = optimizedRoute.slice(1).filter(a => a.completed).length;
  const total = optimizedRoute.length - 1;
  document.getElementById('progress-bar').innerHTML = `<strong>${concluidos} de ${total}</strong> paradas conclu√≠das`;
}

function resetRoute() {
  optimizedRoute = []; activeIndex = 0; addresses = []; departure = null; distanceCache.clear();
  document.getElementById('departure-section').style.display = 'none';
  document.getElementById('add-section').style.display = 'block';
  document.getElementById('route-section').style.display = 'none';
  renderAddressList();
  document.getElementById('optimize-btn').style.display = 'none';
  document.getElementById('status-container').innerHTML = '';
  document.getElementById('base-location-input').value = '';
  document.getElementById('base-location-display').textContent = 'Nenhuma localiza√ß√£o base definida.';
  document.getElementById('departure-input').value = '';
  document.getElementById('departure-display').textContent = 'Nenhum ponto de partida definido.';
  document.getElementById('address-input').value = '';
  stopCamera();
}

function requestVoicePermissionAndStart() {
  if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) return showStatus('Voz n√£o suportada.', 'warning');
  if (!userLocation) return showStatus('Defina localiza√ß√£o base.', 'warning');
  startVoice();
}

function startVoice() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();
  recognition.lang = 'pt-BR';
  const btn = document.getElementById('voice-btn');
  btn.disabled = true;
  recognition.onstart = () => { btn.classList.add('listening'); btn.textContent = 'Ouvindo...'; showStatus('Fale o endere√ßo...', 'info'); };
  recognition.onend = () => { btn.classList.remove('listening'); btn.textContent = 'Voz'; btn.disabled = false; };
  recognition.onresult = (e) => { document.getElementById('address-input').value = e.results[0][0].transcript.trim(); addAddress(); };
  recognition.onerror = (e) => { showStatus('Erro: ' + e.error, 'warning'); };
  recognition.start();
}

async function requestCameraPermissionAndStart(mode) {
  if (!userLocation) return showStatus('Defina localiza√ß√£o base.', 'warning');
  isPhotoMode = mode === 'photo';
  scannerType = isPhotoMode ? null : mode;
  let buttonsHTML = isPhotoMode ? `<button class="btn btn-capture" onclick="captureImage()">Capturar Foto</button>` : `<button class="btn btn-capture" onclick="captureForScan()">Capturar Frame</button>`;
  buttonsHTML += `<button class="btn btn-cancel" onclick="stopCamera()">Cancelar</button>`;
  document.getElementById('camera-buttons').innerHTML = buttonsHTML;
  await startCamera();
}

let scanInterval = null;
async function startCamera() {
  try {
    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } });
    const video = document.getElementById('camera-video');
    video.srcObject = cameraStream;
    document.getElementById('camera-container').style.display = 'block';
    if (scanInterval) clearInterval(scanInterval);
    if (!isPhotoMode && scannerType) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      scanInterval = setInterval(() => {
        if (video.readyState === video.HAVE_ENOUGH_DATA && video.videoWidth > 0) {
          canvas.width = video.videoWidth; canvas.height = video.videoHeight;
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          if (scannerType === 'qr') {
            const code = jsQR(imageData.data, canvas.width, canvas.height);
            if (code) { handleScannedCode(code.data); clearInterval(scanInterval); stopCamera(); }
          }
        }
      }, 500);
    }
  } catch (e) { showStatus('Erro na c√¢mera.', 'warning'); }
}

async function captureForScan() {
  const video = document.getElementById('camera-video');
  if (video.videoWidth === 0) return;
  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  if (scannerType === 'qr') {
    const code = jsQR(imageData.data, canvas.width, canvas.height);
    if (code) { handleScannedCode(code.data); stopCamera(); return; }
  } else if (scannerType === 'barcode') {
    Quagga.decodeSingle({ decoder: { readers: ['code_128_reader', 'ean_reader', 'code_39_reader'] }, locate: true, src: canvas.toDataURL('image/png') }, (result) => {
      if (result?.codeResult) { handleScannedCode(result.codeResult.code); stopCamera(); }
      else { showStatus('N√£o detectado.', 'warning'); }
    });
    return;
  }
  showStatus('N√£o detectado.', 'warning');
}

function stopCamera() {
  if (scanInterval) clearInterval(scanInterval);
  if (cameraStream) cameraStream.getTracks().forEach(t => t.stop());
  document.getElementById('camera-container').style.none = 'none';
}

async function captureImage() {
  const video = document.getElementById('camera-video');
  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  canvas.getContext('2d').drawImage(video, 0, 0);
  showStatus('Extraindo texto...', 'info');
  try {
    const result = await Tesseract.recognize(canvas.toDataURL('image/png'), 'por');
    document.getElementById('address-input').value = result.data.text.trim().replace(/\n/g, ' ');
    addAddress();
  } catch (err) { showStatus('Erro no OCR.', 'warning'); }
  stopCamera();
}

function handleScannedCode(code) { document.getElementById('address-input').value = code; addAddress(); }
function addUserLocationManually() { showStatus('Use o bot√£o em ‚ÄúPonto de Partida‚Äù.', 'info'); }
function showStatus(message, type = 'info') {
  const c = document.getElementById('status-container');
  const cls = type === 'success' ? 'status-success' : type === 'warning' ? 'status-warning' : 'status-info';
  c.innerHTML = `<div class="status-bar ${cls}">${message}</div>`;
  if (type !== 'warning') setTimeout(() => c.innerHTML = '', 5000);
}
function uploadPdf() { document.getElementById('pdf-upload').click(); }
async function processPdf(e) {
  const file = e.target.files[0];
  if (!file) return;
  showStatus('Lendo PDF...', 'info');
  try {
    const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
    let fullText = '';
    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const text = await page.getTextContent();
      fullText += text.items.map(item => item.str).join(' ') + ' ';
    }
    const pattern = /Endere√ßo:\s*(.+?),\s*(\d{1,6})\s+CEP:\s*(\d{5})-?(\d{3})/gi;
    const matches = [...fullText.matchAll(pattern)];
    if (matches.length === 0) return showStatus('Nenhum endere√ßo encontrado.', 'warning');
    for (const m of matches) {
      const addr = `${m[1].trim()}, ${m[2].trim()}, CEP: ${m[3]}-${m[4]}`;
      const coords = await geocodeBasic(addr);
      addresses.push({ id: Date.now() + Math.random(), text: addr, coords: coords || null, completed: false });
    }
    renderAddressList();
    document.getElementById('optimize-btn').style.display = 'block';
    showStatus(`${matches.length} endere√ßos adicionados!`, 'success');
  } catch (err) { showStatus('Erro no PDF.', 'warning'); }
  finally { e.target.value = ''; }
}
function deleteAddress(id) {
  addresses = addresses.filter(a => a.id !== id);
  renderAddressList();
  if (addresses.length === 0) document.getElementById('optimize-btn').style.display = 'none';
}
</script>
</body>
</html>
