<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Otimizador de Rotas</title>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<script src="https://serratus.github.io/quaggaJS/dist/quagga.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/legacy/build/pdf.min.js"></script>
<!-- Adicione esta linha logo após pdf.min.js -->
<script>
    // Configura o worker assim que a biblioteca principal carrega
    if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/legacy/build/pdf.worker.min.js';
    } else {
        console.error('Biblioteca pdf.min.js não carregada antes da configuração do worker.');
    }
</script>
<style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background: #f5f5f5;
      color: #333;
      min-height: 100vh;
      padding: 20px;
      padding-bottom: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .container {
      max-width: 100%;
      width: 100%;
      margin: 0 auto;
      padding: 0 10px;
    }
    .header {
      text-align: center;
      color: white;
      margin-bottom: 20px;
      background: #0056b3;
      padding: 15px 20px;
      border-radius: 10px 10px 0 0;
    }
    .header h1 {
      font-size: 28px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .card {
      background: white;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      margin-bottom: 20px;
    }
    .status-bar {
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 15px;
      font-size: 14px;
    }
    .status-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .status-info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    .status-warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    .tip-box {
      background: #e3f2fd;
      border-left: 4px solid #0056b3;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .tip-box strong {
      display: block;
      margin-bottom: 5px;
      color: #0056b3;
    }
    .tip-box small {
      display: block;
      margin-top: 8px;
      font-size: 12px;
      color: #555;
    }
    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    input[type="text"] {
      flex: 1;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 16px;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #0056b3;
      box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.1);
    }
    .btn {
      padding: 15px 25px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .btn-primary {
      background: #0056b3;
      color: white;
    }
    .btn-primary:hover {
      background: #004494;
    }
    .btn-voice {
      background: #e9ecef;
      color: #333;
      flex: 1;
    }
    .btn-voice.listening {
      background: #ef5350;
      color: white;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .btn-optimize {
      position: fixed;
      bottom: 20px;
      left: 20px;
      right: 20px;
      width: auto;
      background: #0056b3;
      color: white;
      font-size: 18px;
      padding: 18px;
      box-shadow: 0 4px 12px rgba(0, 86, 179, 0.2);
      z-index: 1000;
    }
    .btn-optimize:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .spinner {
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      animation: spin 1s linear infinite;
      display: inline-block;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .btn-small {
      padding: 10px 15px;
      font-size: 14px;
    }
    .buttons-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }
    .address-list {
      margin-bottom: 20px;
    }
    .address-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 15px;
      background: #f8f9fa;
      border: 1px solid #eee;
      border-radius: 8px;
      margin-bottom: 10px;
      cursor: default;
    }
    .address-number {
      background: #0056b3;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      flex-shrink: 0;
    }
    .address-text {
      flex: 1;
      font-size: 14px;
    }
    .btn-delete {
      background: #ff5252;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      flex-shrink: 0;
    }
    .route-item {
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 15px;
      border: 1px solid #ddd;
    }
    .route-item.active {
      background: #cce5ff;
      border-color: #0056b3;
      box-shadow: 0 2px 8px rgba(0, 86, 179, 0.1);
    }
    .route-item.completed {
      background: #e8f5e9;
      border-color: #4caf50;
    }
    .route-header {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 15px;
    }
    .route-number {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      flex-shrink: 0;
    }
    .route-number.active {
      background: #0056b3;
      color: white;
    }
    .route-number.completed {
      background: #4caf50;
      color: white;
    }
    .route-text {
      flex: 1;
    }
    .route-text strong {
      display: block;
      margin-bottom: 5px;
      font-size: 16px;
    }
    .route-text small {
      color: #666;
      font-size: 13px;
    }
    .route-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 8px;
    }
    .btn-maps {
      background: #007bff;
      color: white;
    }
    .btn-waze {
      background: #00d9ff;
      color: white;
    }
    .btn-complete {
      background: #4caf50;
      color: white;
      width: 45px;
    }
    .progress-bar {
      background: #e8eaf6;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      margin-top: 20px;
    }
    .progress-bar strong {
      color: #0056b3;
      font-size: 18px;
    }
    #camera-container {
      margin-bottom: 20px;
    }
    #camera-video {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 10px;
    }
    .camera-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .btn-capture {
      background: #4caf50;
      color: white;
    }
    .btn-cancel {
      background: #f44336;
      color: white;
    }
    .header-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .btn-reset {
      background: #f44336;
      color: white;
    }
    .base-location-section {
      background: #fff8e1;
      border: 1px dashed #ffc107;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }
    .base-location-display {
      font-size: 14px;
      color: #555;
      text-align: center;
      margin-top: 10px;
    }
    .suggestion-item {
      background: #f0f8ff !important;
      cursor: pointer;
    }
    .suggestion-item:hover {
      background: #e3f2fd !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>
        </svg>
        Otimizador de Rotas
      </h1>
    </div>

    <div id="status-container"></div>

    <div id="base-location-section" class="card base-location-section">
      <h3 style="margin-bottom: 10px; color: #333;">Localização Base</h3>
      <p style="margin-bottom: 15px; font-size: 14px; color: #555;">Defina a cidade/região onde você deseja adicionar os endereços.</p>
      <div class="base-location-input-group">
        <input type="text" id="base-location-input" placeholder="Ex: São Paulo, SP" />
        <button class="btn btn-primary" style="padding:12px 16px; font-size:16px;" onclick="setBaseLocation()">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>
        </button>
      </div>
      <div id="base-location-display" class="base-location-display">
        Nenhuma localização base definida. Por favor, defina para continuar.
      </div>
    </div>

    <div id="departure-section" class="card" style="display: none;">
      <h3 style="margin-bottom: 10px; color: #333;">Ponto de Partida</h3>
      <p style="margin-bottom: 15px; font-size: 14px; color: #555;">De onde você vai iniciar a rota?</p>
      <div class="input-group">
        <input type="text" id="departure-input" placeholder="Ex: Av. Paulista, 1000 ou CEP 01310-100" />
        <button class="btn btn-primary" onclick="setDepartureAddress()">+</button>
      </div>
      <button class="btn btn-voice" style="width:100%; margin-top:10px;" onclick="setDepartureCurrentLocation()">
        Usar Minha Localização Atual
      </button>
      <div id="departure-display" class="base-location-display" style="margin-top:10px;">
        Nenhum ponto de partida definido.
      </div>
    </div>

    <div id="add-section" class="card">
      <h2 style="margin-bottom: 15px; color: #333;">Adicionar Endereços</h2>
      <div class="tip-box">
        <strong>Dica de uso:</strong>
        Use endereços completos ou CEP para melhores resultados!
        <small>Exemplos: "Av. Paulista, 1578, São Paulo, SP" • "85855-185" • "85855185, 555" • "CEP: 85855-185"</small>
      </div>
      <div class="input-group">
        <input type="text" id="address-input" placeholder="Ex: Av. Paulista, 1578 ou CEP 01310-100" />
        <button class="btn btn-primary" onclick="addAddress()">+</button>
      </div>
      <div class="buttons-grid">
        <button class="btn btn-voice" id="voice-btn" onclick="requestVoicePermissionAndStart()">Voz</button>
        <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('photo')">Foto</button>
        <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('barcode')">Código</button>
        <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('qr')">QR</button>
        <button class="btn btn-voice" onclick="addUserLocationManually()">Minha Posição</button>
        <button class="btn btn-voice" onclick="uploadPdf()">PDF</button>
      </div>

      <div id="camera-container" style="display: none;">
        <video id="camera-video" autoplay playsinline></video>
        <div class="camera-buttons" id="camera-buttons"></div>
      </div>

      <div id="address-list" class="address-list"></div>
      
      <div id="suggestions-container" class="address-list" style="display: none;"></div>
    </div>

    <div id="route-section" class="card" style="display: none;">
      <div class="header-actions">
        <h2 style="color: #333;">Rota Otimizada</h2>
        <button class="btn btn-reset btn-small" onclick="resetRoute()">Reiniciar</button>
      </div>
      <div id="route-list"></div>
      <div id="progress-bar" class="progress-bar"></div>
    </div>

    <button id="optimize-btn" class="btn btn-optimize" onclick="optimizeRoute()" style="display: none;">
      Otimizar Rota
    </button>
    <input type="file" id="pdf-upload" accept=".pdf" style="display:none;" onchange="processPdf(event)">
</div>

  <script>
    let addresses = [];
    let optimizedRoute = [];
    let activeIndex = 0;
    let userLocation = null;
    let departure = null;
    let isListening = false;
    let cameraStream = null;
    let scannerType = null;
    let isPhotoMode = false;
    let distanceCache = new Map();

    function getCacheKey(lat1, lon1, lat2, lon2) {
      if (lat1 < lat2 || (lat1 === lat2 && lon1 < lon2)) {
        return `${lat1},${lon1}|${lat2},${lon2}`;
      } else {
        return `${lat2},${lon2}|${lat1},${lon1}`;
      }
    }

    window.onload = () => {
      document.getElementById('address-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') addAddress();
      });
      document.getElementById('base-location-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          setBaseLocation();
        }
      });
      document.getElementById('departure-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') setDepartureAddress();
      });
    };

    // === Geocodificação (apenas Nominatim + ViaCEP) ===
    async function processCEP(text) {
      const cepMatch = text.match(/(?:cep\s*:?\s*)?(\d{5})-?(\d{3})(?:\s*,?\s*(\d+))?/i);
      if (cepMatch) {
        const cep = cepMatch[1] + cepMatch[2];
        const numero = cepMatch[3] || '';
        showStatus('Buscando CEP...', 'info');
        try {
          const resp = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
          const data = await resp.json();
          if (data.erro) throw new Error('CEP não encontrado');

          let endereco = data.logradouro || '';
          if (numero) endereco += `, ${numero}`;
          if (data.bairro) endereco += `, ${data.bairro}`;
          endereco += `, ${data.localidade}, ${data.uf}`;
          showStatus('CEP encontrado!', 'success');

          let coords = await geocodeBasic(`${endereco}, Brasil`);
          if (!coords) {
            const cityState = `${data.localidade}, ${data.uf}`;
            coords = await geocodeBasic(cityState);
            if (coords) showStatus('Coordenadas aproximadas (cidade)', 'warning');
          }

          return { success: true, address: endereco, coords: coords || null };
        } catch (e) {
          showStatus('CEP inválido: ' + e.message, 'warning');
          return { success: false, address: text, coords: null };
        }
      }
      return null;
    }

    async function geocodeBasic(address) {
      try {
        const resp = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1&accept-language=pt-BR`,
          { headers: { 'User-Agent': 'RouteOptimizerApp/1.0' } }
        );
        const data = await resp.json();
        if (data?.length > 0) {
          return {
            lat: parseFloat(data[0].lat),
            lon: parseFloat(data[0].lon),
            display_name: data[0].display_name
          };
        }
      } catch (e) {
        console.error('Erro na geocodificação (Nominatim):', e);
      }
      return null;
    }

    async function addAddress() {
      if (!userLocation) return showStatus('Defina a localização base primeiro.', 'warning');
      
      const input = document.getElementById('address-input');
      let text = input.value.trim();
      if (!text) return;

      const cepResult = await processCEP(text);
      if (cepResult?.success && cepResult.coords) {
        addresses.push({ id: Date.now(), text: cepResult.address, coords: cepResult.coords, completed: false });
        input.value = '';
        renderAddressList();
        document.getElementById('optimize-btn').style.display = 'block';
        showStatus('Endereço adicionado via CEP!', 'success');
        return;
      }

      await searchAndSelectAddress(text);
    }

    async function searchAndSelectAddress(query) {
      const suggestionsContainer = document.getElementById('suggestions-container');
      suggestionsContainer.style.display = 'block';
      suggestionsContainer.innerHTML = '<div class="status-bar status-info">Buscando endereços...</div>';

      try {
        const cityState = `${userLocation.city}, ${userLocation.state}, Brasil`;
        const fullQuery = `${query}, ${cityState}`;

        const resp = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullQuery)}&limit=5&addressdetails=1&accept-language=pt-BR`,
          { headers: { 'User-Agent': 'RouteOptimizerApp/1.0' } }
        );
        const results = await resp.json();

        if (!results || results.length === 0) {
          suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Nenhum endereço encontrado. Tente com CEP.</div>';
          setTimeout(() => suggestionsContainer.style.display = 'none', 4000);
          return;
        }

        let html = '<h4 style="margin:10px 0;color:#333;">Escolha o endereço correto:</h4>';
        results.forEach((res, i) => {
          const addr = res.address || {};
          const street = addr.road || '';
          const number = addr.house_number || '';
          const neighborhood = addr.suburb || addr.neighbourhood || addr.city_district || '—';
          const postcode = addr.postcode || '';
          const city = addr.city || userLocation.city;
          const display = `${street}${number ? ', ' + number : ''} – ${neighborhood}${postcode ? ' (CEP: ' + postcode + ')' : ''}`;
          
          html += `
            <div class="address-item suggestion-item" onclick="selectSuggestion(${i})">
              <div style="font-size:14px;">${display}</div>
              <small style="color:#666;">${city}, ${userLocation.state}</small>
            </div>
          `;
        });

        suggestionsContainer.innerHTML = html;
        window.pendingSuggestions = results;
      } catch (e) {
        console.error('Erro ao buscar sugestões:', e);
        suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Erro na busca. Tente novamente.</div>';
        setTimeout(() => suggestionsContainer.style.display = 'none', 4000);
      }
    }

    function selectSuggestion(index) {
      const result = window.pendingSuggestions?.[index];
      if (!result) return;

      const addr = result.address || {};
      let displayText = result.display_name;

      if (addr.road || addr.house_number) {
        displayText = `${addr.road || ''}${addr.house_number ? ', ' + addr.house_number : ''}`;
        if (addr.suburb) displayText += `, ${addr.suburb}`;
        if (addr.city) displayText += `, ${addr.city}`;
        if (addr.state) displayText += ` - ${addr.state}`;
      }

      addresses.push({
        id: Date.now(),
        text: displayText,
        coords: {
          lat: parseFloat(result.lat),
          lon: parseFloat(result.lon),
          display_name: result.display_name
        },
        completed: false
      });

      document.getElementById('address-input').value = '';
      renderAddressList();
      document.getElementById('optimize-btn').style.display = 'block';
      document.getElementById('suggestions-container').style.display = 'none';
      showStatus('Endereço adicionado!', 'success');
    }

    function setBaseLocation() {
      const input = document.getElementById('base-location-input');
      const text = input.value.trim();
      if (!text) return showStatus('Informe cidade e estado.', 'warning');
      geocodeBaseLocation(text);
    }

    async function geocodeBaseLocation(locationText) {
      showStatus('Verificando localização base...', 'info');
      try {
        const data = await (await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationText + ', Brasil')}&limit=1&addressdetails=1&accept-language=pt-BR`,
          { headers: { 'User-Agent': 'RouteOptimizerApp/1.0' } }
        )).json();

        if (!data?.length) throw new Error('Nenhum resultado encontrado. Use “Cidade, Estado”.');

        const addr = data[0].address || {};
        const city = addr.city || addr.town || addr.municipality || addr.village || '';
        const state = addr.state || '';
        if (!city) throw new Error('Cidade não identificada.');

        userLocation = { city, state };
        document.getElementById('base-location-display').textContent = `Localização base: ${city}${state ? ', ' + state : ''}.`;
        document.getElementById('address-input').placeholder = `Ex: Rua das Flores, 123 ou CEP (em ${city})`;
        document.getElementById('departure-section').style.display = 'block';
        showStatus(`Localização base definida: ${city}${state ? ', ' + state : ''}`, 'success');
      } catch (error) {
        console.error('Erro na localização base:', error);
        showStatus(`${error.message}`, 'warning');
        userLocation = null;
        document.getElementById('base-location-display').textContent = 'Falha ao definir localização base.';
      }
    }

    async function setDepartureAddress() {
      const input = document.getElementById('departure-input');
      const text = input.value.trim();
      if (!text) return showStatus('Digite um endereço de partida.', 'warning');

      const cepResult = await processCEP(text);
      const addressToUse = cepResult?.success ? cepResult.address : text;
      const coords = await geocodeAddressFull(addressToUse);

      if (coords) {
        departure = { text: addressToUse, coords };
        document.getElementById('departure-display').textContent = coords.display_name;
        showStatus('Ponto de partida definido!', 'success');
      } else {
        showStatus('Endereço de partida não encontrado.', 'warning');
      }
    }

    function setDepartureCurrentLocation() {
      if (!navigator.geolocation) return showStatus('Geolocalização não suportada.', 'warning');
      showStatus('Obtendo sua localização...', 'info');
      navigator.geolocation.getCurrentPosition(
        async (pos) => {
          const { latitude, longitude } = pos.coords;
          try {
            const data = await (await fetch(
              `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&accept-language=pt-BR`,
              { headers: { 'User-Agent': 'RouteOptimizerApp/1.0' } }
            )).json();
            const name = data.display_name || `Lat: ${latitude}, Lng: ${longitude}`;
            departure = { text: 'Minha localização atual', coords: { lat: latitude, lon: longitude, display_name: name } };
            document.getElementById('departure-display').textContent = name;
            showStatus('Partida definida com sucesso!', 'success');
          } catch (e) {
            departure = {
              text: 'Minha localização atual',
              coords: { lat: latitude, lon: longitude, display_name: `(${latitude.toFixed(5)}, ${longitude.toFixed(5)})` }
            };
            document.getElementById('departure-display').textContent = departure.coords.display_name;
            showStatus('Localização usada sem nome.', 'info');
          }
        },
        (err) => showStatus('Erro na localização: ' + err.message, 'warning'),
        { timeout: 10000 }
      );
    }

    async function geocodeAddressFull(address) {
      let full = address + ', Brasil';
      if (userLocation) {
        full = `${address}, ${userLocation.city}${userLocation.state ? ', ' + userLocation.state : ''}, Brasil`;
      }

      let coords = await geocodeBasic(full);
      if (coords) return coords;

      if (userLocation) {
        const fallback = `${userLocation.city}, ${userLocation.state}, Brasil`;
        coords = await geocodeBasic(fallback);
        if (coords) {
          showStatus('Coordenadas aproximadas (cidade)', 'warning');
          return coords;
        }
      }
      return null;
    }

    function deleteAddress(id) {
      addresses = addresses.filter(a => a.id !== id);
      renderAddressList();
      if (addresses.length === 0) document.getElementById('optimize-btn').style.display = 'none';
    }

    async function calculateRealDistance(from, to) {
      const key = getCacheKey(from.lat, from.lon, to.lat, to.lon);
      if (distanceCache.has(key)) return distanceCache.get(key);

      try {
        const url = `https://router.project-osrm.org/route/v1/driving/${from.lon},${from.lat};${to.lon},${to.lat}?overview=false`;
        const resp = await fetch(url);
        const data = await resp.json();
        if (data.code === 'Ok' && data.routes?.length > 0) {
          const result = { distance: data.routes[0].distance, duration: data.routes[0].duration };
          distanceCache.set(key, result);
          return result;
        }
      } catch (e) {
        console.warn('OSRM falhou, usando distância em linha reta:', e);
      }

      const R = 6371000;
      const φ1 = from.lat * Math.PI / 180;
      const φ2 = to.lat * Math.PI / 180;
      const Δφ = (to.lat - from.lat) * Math.PI / 180;
      const Δλ = (to.lon - from.lon) * Math.PI / 180;
      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const distance = R * c;
      const duration = distance / 13.89;
      const result = { distance, duration };
      distanceCache.set(key, result);
      return result;
    }

    async function optimizeRouteNearestNeighbor(start, destinations) {
      const route = [];
      const remaining = [...destinations];
      let current = start;
      while (remaining.length > 0) {
        let nearest = null;
        let minDist = Infinity;
        let minIndex = -1;
        for (let i = 0; i < remaining.length; i++) {
          const { distance } = await calculateRealDistance(current.coords, remaining[i].coords);
          if (distance < minDist) {
            minDist = distance;
            nearest = remaining[i];
            minIndex = i;
          }
        }
        if (nearest) {
          route.push(nearest);
          remaining.splice(minIndex, 1);
          current = nearest;
        }
      }
      return route;
    }

    async function twoOptImprovement(route, start) {
      let improved = true;
      let currentRoute = [...route];
      while (improved) {
        improved = false;
        for (let i = 0; i < currentRoute.length - 2; i++) {
          for (let j = i + 2; j < currentRoute.length - 1; j++) {
            const prev = i === 0 ? start : currentRoute[i - 1];
            const [d1, d2, d3, d4] = await Promise.all([
              calculateRealDistance(prev.coords, currentRoute[i].coords),
              calculateRealDistance(currentRoute[j].coords, currentRoute[j + 1].coords),
              calculateRealDistance(prev.coords, currentRoute[j].coords),
              calculateRealDistance(currentRoute[i].coords, currentRoute[j + 1].coords)
            ]);
            if (d3.distance + d4.distance < d1.distance + d2.distance) {
              const segment = currentRoute.slice(i, j + 1).reverse();
              currentRoute = [...currentRoute.slice(0, i), ...segment, ...currentRoute.slice(j + 1)];
              improved = true;
            }
          }
        }
      }
      return currentRoute;
    }

    async function optimizeRoute() {
      if (!departure || addresses.length === 0) return showStatus('Defina partida e destinos.', 'warning');
      const btn = document.getElementById('optimize-btn');
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner"></span> Otimizando...';

      try {
        const destinos = addresses.map(a => ({ ...a }));
        let optimized = await optimizeRouteNearestNeighbor(departure, destinos);
        if (optimized.length > 3) {
          showStatus('Refinando rota...', 'info');
          optimized = await twoOptImprovement(optimized, departure);
        }

        let totalDistance = 0, totalDuration = 0, prev = departure;
        for (const dest of optimized) {
          const { distance, duration } = await calculateRealDistance(prev.coords, dest.coords);
          totalDistance += distance;
          totalDuration += duration;
          prev = dest;
        }

        optimized.forEach(d => d.completed = false);
        optimizedRoute = [{ ...departure, completed: true }, ...optimized];
        activeIndex = 1;
        document.getElementById('add-section').style.display = 'none';
        document.getElementById('route-section').style.display = 'block';
        await renderRoute();

        const distKm = (totalDistance / 1000).toFixed(1);
        const durMin = Math.round(totalDuration / 60);
        showStatus(`Rota otimizada! ${distKm}km · ~${durMin}min`, 'success');
      } catch (e) {
        console.error('Erro na otimização:', e);
        showStatus('Erro: ' + e.message, 'warning');
      } finally {
        btn.disabled = false;
        btn.innerHTML = 'Otimizar Rota';
      }
    }

    function renderAddressList() {
      const list = document.getElementById('address-list');
      if (addresses.length === 0) {
        list.innerHTML = '';
        return;
      }
      let html = '';
      addresses.forEach((addr, i) => {
        html += `
          <div class="address-item">
            <div class="address-number">${i + 1}</div>
            <div class="address-text">${addr.text}</div>
            <button class="btn-delete" onclick="editAddress(${addr.id})" title="Editar">✏️</button>
            <button class="btn-delete" onclick="deleteAddress(${addr.id})" title="Excluir">×</button>
          </div>`;
      });
      list.innerHTML = html;
    }

    function editAddress(id) {
      const addr = addresses.find(a => a.id === id);
      if (!addr) return;
      
      const newText = prompt('Editar endereço:', addr.text);
      if (newText === null || newText.trim() === '') return;
      
      (async () => {
        showStatus('Atualizando endereço...', 'info');
        const coords = await geocodeAddressFull(newText.trim());
        if (coords) {
          addr.text = newText.trim();
          addr.coords = coords;
          renderAddressList();
          showStatus('Endereço atualizado!', 'success');
        } else {
          showStatus('Não foi possível localizar o novo endereço.', 'warning');
        }
      })();
    }

    async function renderRoute() {
      const list = document.getElementById('route-list');
      let html = '';
      for (let i = 0; i < optimizedRoute.length; i++) {
        const a = optimizedRoute[i];
        const ativo = i === activeIndex && !a.completed;
        const concluido = a.completed;
        let distInfo = '';

        if (i > 0) {
          try {
            const { distance, duration } = await calculateRealDistance(optimizedRoute[i - 1].coords, a.coords);
            distInfo = `<small style="color:#0056b3;">${(distance / 1000).toFixed(1)}km · ${Math.round(duration / 60)}min</small>`;
          } catch (e) {
            distInfo = `<small style="color:#ff5252;">Distância não calculada</small>`;
          }
        }

        html += `
        <div class="route-item ${ativo ? 'active' : ''} ${concluido ? 'completed' : ''}">
          <div class="route-header">
            <div class="route-number ${ativo ? 'active' : ''} ${concluido ? 'completed' : ''}">
              ${concluido ? '✓' : i === 0 ? '' : i}
            </div>
            <div class="route-text">
              <strong>${i === 0 ? 'Ponto de Partida' : a.text}</strong>
              ${a.coords?.display_name ? `<small>${a.coords.display_name}</small>` : '<small style="color:#ff5252;">Localização aproximada</small>'}
              ${distInfo}
            </div>
          </div>
          ${ativo && !concluido ? `
            <div class="route-buttons">
              <button class="btn btn-maps btn-small" onclick="openMaps(${i}, 'google')">Maps</button>
              <button class="btn btn-waze btn-small" onclick="openMaps(${i}, 'waze')">Waze</button>
              <button class="btn btn-complete btn-small" onclick="markCompleted(${i})">✓</button>
            </div>` : ''}
        </div>`;
      }
      list.innerHTML = html;
      updateProgress();
    }

    function openMaps(i, app) {
      const a = optimizedRoute[i];
      const { lat, lon } = a.coords || {};
      if (app === 'google') {
        const url = lat && lon
          ? `https://www.google.com/maps/dir/?api=1&destination=${lat},${lon}`
          : `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(a.text)}`;
        window.open(url, '_blank');
      } else if (app === 'waze') {
        if (lat && lon) {
          const wazeUrl = `waze://?ll=${lat},${lon}&navigate=yes`;
          const iframe = document.createElement('iframe');
          iframe.style.display = 'none';
          iframe.src = wazeUrl;
          document.body.appendChild(iframe);
          setTimeout(() => {
            document.body.removeChild(iframe);
            if (document.hasFocus()) {
              window.open(`https://www.waze.com/ul?ll=${lat},${lon}&navigate=yes`, '_blank');
              showStatus('Waze não encontrado. Abrindo no navegador...', 'info');
            }
          }, 2000);
        } else {
          window.open(`https://www.waze.com/ul?q=${encodeURIComponent(a.text)}`, '_blank');
        }
      }
    }

    function markCompleted(i) {
      optimizedRoute[i].completed = true;
      if (i < optimizedRoute.length - 1) activeIndex = i + 1;
      renderRoute();
    }

    function updateProgress() {
      const concluidos = optimizedRoute.slice(1).filter(a => a.completed).length;
      const total = optimizedRoute.length - 1;
      document.getElementById('progress-bar').innerHTML = `<strong>${concluidos} de ${total}</strong> paradas concluídas`;
    }

    function resetRoute() {
      optimizedRoute = [];
      activeIndex = 0;
      addresses = [];
      departure = null;
      userLocation = null;
      distanceCache.clear();
      document.getElementById('base-location-section').style.display = 'block';
      document.getElementById('departure-section').style.display = 'none';
      document.getElementById('add-section').style.display = 'block';
      document.getElementById('route-section').style.display = 'none';
      renderAddressList();
      document.getElementById('optimize-btn').style.display = 'none';
      document.getElementById('status-container').innerHTML = '';
      document.getElementById('base-location-input').value = '';
      document.getElementById('base-location-display').textContent = 'Nenhuma localização base definida. Por favor, defina para continuar.';
      document.getElementById('departure-input').value = '';
      document.getElementById('departure-display').textContent = 'Nenhum ponto de partida definido.';
      document.getElementById('address-input').value = '';
      document.getElementById('suggestions-container').style.display = 'none';
      stopCamera();
    }

    function requestVoicePermissionAndStart() {
      if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
        return showStatus('Voz não suportada.', 'warning');
      }
      if (!userLocation) return showStatus('Defina localização base.', 'warning');
      startVoice();
    }

    function startVoice() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();
      recognition.lang = 'pt-BR';
      recognition.interimResults = false;
      const btn = document.getElementById('voice-btn');
      btn.disabled = true;
      recognition.onstart = () => {
        isListening = true;
        btn.classList.add('listening');
        btn.textContent = 'Ouvindo...';
        showStatus('Fale o endereço...', 'info');
      };
      recognition.onend = () => {
        isListening = false;
        btn.classList.remove('listening');
        btn.textContent = 'Voz';
        btn.disabled = false;
      };
      recognition.onresult = (e) => {
        const t = e.results[0][0].transcript.trim();
        document.getElementById('address-input').value = t;
        addAddress();
      };
      recognition.onerror = (e) => {
        const msg = e.error === 'not-allowed' ? 'Permissão de microfone negada.' : e.error;
        showStatus('Erro: ' + msg, 'warning');
        recognition.onend();
      };
      recognition.start();
    }

async function requestCameraPermissionAndStart(mode) {
  if (!userLocation) return showStatus('Defina localização base.', 'warning');
  isPhotoMode = mode === 'photo';
  scannerType = isPhotoMode ? null : mode;

  // Sempre mostra os dois botões para barcode/QR (Capturar + Cancelar)
  // Para foto mantém como antes
  let buttonsHTML = '';
  if (isPhotoMode) {
    buttonsHTML = `<button class="btn btn-capture" onclick="captureImage()">Capturar Foto</button>`;
  } else {
    buttonsHTML = `<button class="btn btn-capture" onclick="captureForScan()">Capturar Frame</button>`;
  }
  buttonsHTML += `<button class="btn btn-cancel" onclick="stopCamera()">Cancelar</button>`;
  document.getElementById('camera-buttons').innerHTML = buttonsHTML;

  await startCamera();
}

let scanInterval = null; // para limpar o interval

async function startCamera() {
  try {
    cameraStream = await navigator.mediaDevices.getUserMedia({ 
      video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } 
    });
    const video = document.getElementById('camera-video');
    video.srcObject = cameraStream;
    document.getElementById('camera-container').style.display = 'block';

    // Limpa interval anterior se existir
    if (scanInterval) clearInterval(scanInterval);

    if (!isPhotoMode && scannerType) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      scanInterval = setInterval(() => {
        if (video.readyState === video.HAVE_ENOUGH_DATA && video.videoWidth > 0 && video.videoHeight > 0) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

          if (scannerType === 'qr') {
            const code = jsQR(imageData.data, canvas.width, canvas.height);
            if (code) {
              handleScannedCode(code.data);
              clearInterval(scanInterval);
              stopCamera();
            }
          } else if (scannerType === 'barcode') {
            // Para barcode, NÃO usamos decodeSingle em loop (problemático)
            // Deixamos só detecção manual via botão
            // (opcional: você pode tentar jsQR para 1D também, mas Quagga é melhor para 1D)
          }
        }
      }, 500); // Aumentei para 500ms → menos carga na bateria/CPU
    }
  } catch (e) {
    showStatus('Erro na câmera: ' + (e.name === 'NotAllowedError' ? 'Permissão negada' : 'Erro desconhecido'), 'warning');
    document.getElementById('camera-container').style.display = 'none';
  }
}

// Nova função: captura frame atual e tenta detectar (manual)
async function captureForScan() {
  const video = document.getElementById('camera-video');
  if (video.videoWidth === 0 || video.videoHeight === 0) {
    showStatus('Frame não pronto ainda. Tente novamente.', 'warning');
    return;
  }

  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  showStatus('Processando frame capturado...', 'info');

  if (scannerType === 'qr') {
    const code = jsQR(imageData.data, canvas.width, canvas.height);
    if (code) {
      handleScannedCode(code.data);
      stopCamera();
      return;
    }
  } else if (scannerType === 'barcode') {
    // Usa Quagga.decodeSingle apenas uma vez (no frame capturado) → mais confiável
    Quagga.decodeSingle({
      decoder: { readers: ['code_128_reader', 'ean_reader', 'ean_8_reader', 'code_39_reader', 'codabar_reader', 'upc_reader', 'i2of5_reader'] },
      locate: true,
      src: canvas.toDataURL('image/png')
    }, (result) => {
      if (result && result.codeResult) {
        handleScannedCode(result.codeResult.code);
        stopCamera();
      } else {
        showStatus('Código não detectado neste frame. Tente reposicionar.', 'warning');
      }
    });
    return;
  }

  showStatus('Código não detectado. Tente novamente.', 'warning');
}

function stopCamera() {
  if (scanInterval) {
    clearInterval(scanInterval);
    scanInterval = null;
  }
  if (cameraStream) {
    cameraStream.getTracks().forEach(t => t.stop());
    cameraStream = null;
  }
  document.getElementById('camera-container').style.display = 'none';
}
    async function captureImage() {
      const video = document.getElementById('camera-video');
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext('2d').drawImage(video, 0, 0);
      showStatus('Extraindo texto...', 'info');
      try {
        const result = await Tesseract.recognize(canvas.toDataURL('image/png'), 'por');
        const clean = result.data.text.trim().replace(/\n/g, ' ');
        document.getElementById('address-input').value = clean;
        addAddress();
        showStatus('Texto extraído com sucesso!', 'success');
      } catch (err) {
        console.error('OCR error:', err);
        showStatus('Erro no OCR: tente outra foto.', 'warning');
      }
      stopCamera();
    }

    function stopCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
      }
      document.getElementById('camera-container').style.display = 'none';
    }

    function handleScannedCode(code) {
      document.getElementById('address-input').value = code;
      addAddress();
      showStatus('Código escaneado com sucesso!', 'success');
    }

    function addUserLocationManually() {
      showStatus('Minha Posição: use o botão em “Ponto de Partida”.', 'info');
    }
function showStatus(message, type = 'info') {
    const c = document.getElementById('status-container');
    const cls = type === 'success' ? 'status-success' : type === 'warning' ? 'status-warning' : 'status-info';
    c.innerHTML = `<div class="status-bar ${cls}">${message}</div>`;
    if (type !== 'warning') setTimeout(() => c.innerHTML = '', 5000);
}

function uploadPdf() {
    document.getElementById('pdf-upload').click();
}

// Função auxiliar para extrair CEPs de um bloco de texto
function extractAddressesFromText(text) {
    // Encontra sequências de 8 dígitos (CEPs)
    const cepRegex = /(\d{5})-?(\d{3})/g;
    const foundCEPs = [];
    let match;

    while ((match = cepRegex.exec(text)) !== null) {
        const cep = match[1] + match[2]; // Junta os grupos para formar o CEP de 8 dígitos
        const cepIndex = match.index;
        // Tenta encontrar um pedaço de texto razoável antes do CEP
        // Procura o final da linha anterior ou um ponto
        const contextStart = text.lastIndexOf('\n', cepIndex); // Tenta encontrar a quebra de linha antes
        if (contextStart === -1) continue; // Ignora se não encontrar quebra de linha

        const contextEnd = text.indexOf('\n', cepIndex); // Tenta encontrar a quebra de linha depois
        const line = text.substring(contextStart + 1, contextEnd !== -1 ? contextEnd : cepIndex).trim();

        // Tenta isolar uma parte que pareça um endereço (rua, número) antes do CEP
        // Esta é uma tentativa simplificada, pode precisar de ajustes
        // Exemplo: "Rua Exemplo, 123 - 01234567"
        const addressMatch = line.match(/^(.*?)(?:\s*-\s*|\s+)(\d{5}-?\d{3})$/); // Tenta capturar antes do CEP na mesma linha
        if (addressMatch) {
            foundCEPs.push({
                fullText: addressMatch[0],
                addressPart: addressMatch[1].trim(),
                cep: addressMatch[2].replace('-', '')
            });
        } else {
             // Se não encontrar um padrão exato, usa a linha inteira como parte do endereço
             foundCEPs.push({
                 fullText: line,
                 addressPart: line.replace(new RegExp(cep, 'g'), '').trim(), // Remove o CEP da linha
                 cep: cep
             });
        }
    }
    return foundCEPs;
}
async function processPdf(e) {
    const file = e.target.files[0];
    if (!file) return;

    showStatus('Carregando e analisando PDF...', 'info');

    // --- VERIFICAÇÃO ADICIONADA ---
    if (typeof pdfjsLib === 'undefined') {
        showStatus('Erro interno: Biblioteca PDF não carregada. Recarregue a página.', 'warning');
        console.error('pdfjsLib não está definido globalmente. O script pdf.min.js pode não ter carregado corretamente.');
        e.target.value = ''; // Limpa o input
        return;
    }
    // --- FIM DA VERIFICAÇÃO ---

    try {
        // Configura o worker (obrigatório)
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/legacy/build/pdf.worker.min.js';
        const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
        const pdf = await loadingTask.promise;

        let fullText = '';
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
            const page = await pdf.getPage(pageNum);
            const textContent = await page.getTextContent();
            const pageText = textContent.items
                .map(item => item.str)
                .join(' ');
            fullText += pageText + ' ';
        }

        // Regex robusta para o formato dos Correios (testada com seus prints)
        const regex = /Endereço:\s*([^,]+?)\s*,\s*(\d+)\s*CEP:\s*(\d{8})/gi;
        const matches = [...fullText.matchAll(regex)];

        if (matches.length === 0) {
            // Tenta uma regex mais genérica para CEPs se a específica falhar
            const cepRegex = /(\d{5})-?(\d{3})/g;
            const cepMatches = [...fullText.matchAll(cepRegex)];
            if (cepMatches.length > 0) {
                 showStatus(`Nenhum endereço no formato esperado, mas ${cepMatches.length} CEPs encontrados. Adicionando...`, 'info');
                 // Extrai pedaços de texto próximos aos CEPs como endereços
                 let addedCount = 0;
                 for (const cepMatch of cepMatches) {
                     const cep = cepMatch[1] + cepMatch[2]; // Junta 5 e 3 dígitos
                     const cepIndex = cepMatch.index;
                     // Tenta encontrar um pedaço de texto razoável antes do CEP
                     const contextStart = Math.max(0, fullText.lastIndexOf('\n', cepIndex)); // Linha anterior
                     const contextEnd = fullText.indexOf('\n', cepIndex); // Próxima linha
                     const line = fullText.substring(contextStart, contextEnd !== -1 ? contextEnd : fullText.length).trim();
                     // Remove o CEP da linha para formar o endereço
                     const enderecoSemCep = line.replace(new RegExp(cep, 'g'), '').trim();
                     const enderecoCompleto = `${enderecoSemCep} CEP: ${cep}`.trim();
                     if (enderecoCompleto && enderecoCompleto !== `CEP: ${cep}`) { // Verifica se algo além do CEP foi encontrado
                         document.getElementById('address-input').value = enderecoCompleto;
                         await addAddress(); // aguarda geocodificação completa
                         addedCount++;
                     }
                 }
                 if (addedCount > 0) {
                     showStatus(`✅ ${addedCount} endereço(s) adicionado(s) com sucesso do PDF!`, 'success');
                     document.getElementById('optimize-btn').style.display = 'block';
                     renderAddressList();
                 } else {
                     showStatus('Nenhum endereço ou CEP útil encontrado no texto do PDF.', 'warning');
                 }
                 e.target.value = '';
                 return;
            } else {
                showStatus('Nenhum endereço encontrado. Verifique se o PDF contém texto selecionável (não imagem escaneada).', 'warning');
                e.target.value = '';
                return;
            }
        }

        showStatus(`Encontrados ${matches.length} endereços. Adicionando à lista...`, 'info');
        for (const match of matches) {
            const logradouro = match[1].trim(); // inclui bairro entre parênteses
            const numero = match[2].trim();
            const cep = match[3];
            const enderecoCompleto = `${logradouro}, ${numero}, CEP: ${cep}`;
            document.getElementById('address-input').value = enderecoCompleto;
            await addAddress(); // aguarda geocodificação completa
        }

        showStatus(`✅ ${matches.length} endereços adicionados com sucesso do PDF!`, 'success');
        document.getElementById('optimize-btn').style.display = 'block';
        renderAddressList();
    } catch (err) {
        console.error('Erro ao processar PDF:', err);
        showStatus('Erro ao ler o PDF. Certifique-se de que é um PDF com texto selecionável.', 'warning');
    } finally {
        e.target.value = '';
    }

    // 5. Usar a função auxiliar para encontrar endereços
    const foundAddresses = extractAddressesFromText(fullText);

    if (foundAddresses.length === 0) {
        showStatus('Nenhum endereço com CEP encontrado no texto do PDF.', 'warning');
        e.target.value = ''; // Limpa o input
        return;
    }

    // 6. Adicionar endereços encontrados
    showStatus(`Encontrados ${foundAddresses.length} possíveis endereços. Adicionando...`, 'info');
    let addedCount = 0;
    for (const addr of foundAddresses) {
        // Monta o endereço a ser adicionado, tentando ser o mais completo possível
        let enderecoCompleto = addr.addressPart;
        if (addr.cep) {
            // Formata o CEP como 00000-000
            const formattedCep = addr.cep.substring(0, 5) + '-' + addr.cep.substring(5);
            enderecoCompleto += ` CEP: ${formattedCep}`;
        }

        document.getElementById('address-input').value = enderecoCompleto.trim();
        try {
            // Chama addAddress e aguarda sua conclusão para garantir ordem
            await addAddress();
            addedCount++;
        } catch (err) {
            console.error('Erro ao adicionar endereço do PDF:', enderecoCompleto, err);
            // Opcional: mostrar um status intermediário se muitos falharem
        }
    }

    if (addedCount > 0) {
        showStatus(`✅ ${addedCount} endereço(s) adicionado(s) com sucesso do PDF!`, 'success');
        document.getElementById('optimize-btn').style.display = 'block';
        renderAddressList(); // Atualiza a lista visualmente
    } else {
        showStatus('Nenhum endereço pôde ser adicionado.', 'warning');
    }

    e.target.value = '';
}
</script>
</body>
</html>
