<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Otimizador de Rotas</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<script src="https://serratus.github.io/quaggaJS/dist/quagga.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #f5f5f5; color: #333; min-height: 100vh; padding: 20px; padding-bottom: 120px; display: flex; flex-direction: column; align-items: center; }
.container { max-width: 100%; width: 100%; margin: 0 auto; padding: 0 10px; }
.header { text-align: center; color: white; margin-bottom: 20px; background: #0056b3; padding: 15px 20px; border-radius: 10px 10px 0 0; }
.header h1 { font-size: 28px; margin-bottom: 5px; display: flex; align-items: center; justify-content: center; gap: 10px; }
.card { background: white; border: 1px solid #ddd; border-radius: 10px; padding: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); margin-bottom: 20px; }
.status-bar { padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 14px; }
.status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
.status-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
.status-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
.tip-box { background: #e3f2fd; border-left: 4px solid #0056b3; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
.tip-box strong { display: block; margin-bottom: 5px; color: #0056b3; }
.tip-box small { display: block; margin-top: 8px; font-size: 12px; color: #555; }
.input-group { display: flex; gap: 10px; margin-bottom: 15px; }
input[type="text"] { flex: 1; padding: 15px; border: 1px solid #ccc; border-radius: 8px; font-size: 16px; }
input[type="text"]:focus { outline: none; border-color: #0056b3; box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.1); }
.btn { padding: 15px 25px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; }
.btn-primary { background: #0056b3; color: white; }
.btn-primary:hover { background: #004494; }
.btn-voice { background: #e9ecef; color: #333; flex: 1; }
.btn-voice.listening { background: #ef5350; color: white; animation: pulse 1.5s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
.btn-optimize { position: fixed; bottom: 20px; left: 20px; right: 20px; width: auto; background: #0056b3; color: white; font-size: 18px; padding: 18px; box-shadow: 0 4px 12px rgba(0, 86, 179, 0.2); z-index: 1000; }
.btn-optimize:disabled { opacity: 0.6; cursor: not-allowed; }
.spinner { border: 2px solid rgba(255, 255, 255, 0.3); border-top: 2px solid white; border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; display: inline-block; }
@keyframes spin { to { transform: rotate(360deg); } }
.btn-small { padding: 10px 15px; font-size: 14px; }
.buttons-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 10px; margin-bottom: 20px; }
.address-list { margin-bottom: 20px; }
.address-item { display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border: 1px solid #eee; border-radius: 8px; margin-bottom: 10px; cursor: default; }
.address-number { background: #0056b3; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
.address-text { flex: 1; font-size: 14px; }
.btn-delete { background: #ff5252; color: white; width: 35px; height: 35px; border-radius: 6px; border: none; cursor: pointer; flex-shrink: 0; }
.route-item { padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #ddd; }
.route-item.active { background: #cce5ff; border-color: #0056b3; box-shadow: 0 2px 8px rgba(0, 86, 179, 0.1); }
.route-item.completed { background: #e8f5e9; border-color: #4caf50; }
.route-header { display: flex; align-items: flex-start; gap: 10px; margin-bottom: 15px; }
.route-number { width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
.route-number.active { background: #0056b3; color: white; }
.route-number.completed { background: #4caf50; color: white; }
.route-text { flex: 1; }
.route-text strong { display: block; margin-bottom: 5px; font-size: 16px; }
.route-text small { color: #666; font-size: 13px; }
.route-buttons { display: grid; grid-template-columns: 1fr 1fr auto; gap: 8px; }
.btn-maps { background: #007bff; color: white; }
.btn-waze { background: #00d9ff; color: white; }
.btn-complete { background: #4caf50; color: white; width: 45px; }
.progress-bar { background: #e8eaf6; padding: 15px; border-radius: 8px; text-align: center; margin-top: 20px; }
.progress-bar strong { color: #0056b3; font-size: 18px; }
#camera-container { margin-bottom: 20px; }
#camera-video { width: 100%; border-radius: 8px; margin-bottom: 10px; }
.camera-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.btn-capture { background: #4caf50; color: white; }
.btn-cancel { background: #f44336; color: white; }
.header-actions { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
.btn-reset { background: #f44336; color: white; }
.base-location-section { background: #fff8e1; border: 1px dashed #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px; }
.base-location-display { font-size: 14px; color: #555; text-align: center; margin-top: 10px; }
.suggestion-item { background: #f0f8ff !important; cursor: pointer; }
.suggestion-item:hover { background: #e3f2fd !important; }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>
      <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>
      </svg>
      Otimizador de Rotas
    </h1>
  </div>
  <div id="status-container"></div>
  <div id="base-location-section" class="card base-location-section">
    <h3 style="margin-bottom: 10px; color: #333;">Localização Base</h3>
    <p style="margin-bottom: 15px; font-size: 14px; color: #555;">Defina a cidade/região onde você deseja adicionar os endereços.</p>
    <div class="base-location-input-group">
      <input type="text" id="base-location-input" placeholder="Ex: São Paulo, SP" />
      <button class="btn btn-primary" style="padding:12px 16px; font-size:16px;" onclick="setBaseLocation()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </button>
    </div>
    <div id="base-location-display" class="base-location-display">
      Nenhuma localização base definida. Por favor, defina para continuar.
    </div>
  </div>
  <div id="departure-section" class="card" style="display: none;">
    <h3 style="margin-bottom: 10px; color: #333;">Ponto de Partida</h3>
    <p style="margin-bottom: 15px; font-size: 14px; color: #555;">De onde você vai iniciar a rota?</p>
    <div class="input-group">
      <input type="text" id="departure-input" placeholder="Ex: Av. Paulista, 1000 ou 01310-100, 1000" />
      <button class="btn btn-primary" onclick="setDepartureAddress()">+</button>
    </div>
    <div id="departure-suggestions" class="address-list" style="display: none;"></div>
    <button class="btn btn-voice" style="width:100%; margin-top:10px;" onclick="setDepartureCurrentLocation()">
      Usar Minha Localização Atual
    </button>
    <div id="departure-display" class="base-location-display" style="margin-top:10px;">
      Nenhum ponto de partida definido.
    </div>
  </div>
  <div id="add-section" class="card">
    <h2 style="margin-bottom: 15px; color: #333;">Adicionar Endereços</h2>
    <div class="tip-box">
      <strong>Dica de uso:</strong>
      Use endereços completos ou CEP para melhores resultados!
      <small>Exemplos: "Av. Paulista, 1578, São Paulo, SP" • "85855-185" • "85855185, 555" • "CEP: 85855-185"</small>
    </div>
    <div class="input-group">
      <input type="text" id="address-input" placeholder="Ex: Av. Paulista, 1578 ou CEP 01310-100" />
      <button class="btn btn-primary" onclick="addAddress()">+</button>
    </div>
    <div class="buttons-grid">
      <button class="btn btn-voice" id="voice-btn" onclick="requestVoicePermissionAndStart()">Voz</button>
      <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('photo')">Foto</button>
      <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('barcode')">Código</button>
      <button class="btn btn-voice" onclick="requestCameraPermissionAndStart('qr')">QR</button>
      <button class="btn btn-voice" onclick="addUserLocationManually()">Minha Posição</button>
      <button class="btn btn-voice" onclick="uploadPdf()">PDF</button>
    </div>
    <div id="camera-container" style="display: none;">
      <video id="camera-video" autoplay playsinline></video>
      <div class="camera-buttons" id="camera-buttons"></div>
    </div>
    <div id="address-list" class="address-list"></div>
    <div id="suggestions-container" class="address-list" style="display: none;"></div>
  </div>
  <div id="route-section" class="card" style="display: none;">
    <div class="header-actions">
      <h2 style="color: #333;">Rota Otimizada</h2>
      <button class="btn btn-reset btn-small" onclick="resetRoute()">Reiniciar</button>
    </div>
    <div id="route-list"></div>
    <div id="progress-bar" class="progress-bar"></div>
  </div>
  <button id="optimize-btn" class="btn btn-optimize" onclick="optimizeRoute()" style="display: none;">
    Otimizar Rota
  </button>
  <input type="file" id="pdf-upload" accept=".pdf" style="display:none;" onchange="processPdf(event)">
</div>
<script>
let addresses = [];
let optimizedRoute = [];
let activeIndex = 0;
let userLocation = null;
let departure = null;
let isListening = false;
let cameraStream = null;
let scannerType = null;
let isPhotoMode = false;
let distanceCache = new Map();

function getCacheKey(lat1, lon1, lat2, lon2) {
  const p1 = `${lat1.toFixed(6)},${lon1.toFixed(6)}`;
  const p2 = `${lat2.toFixed(6)},${lon2.toFixed(6)}`;
  return p1 < p2 ? `${p1}|${p2}` : `${p2}|${p1}`;
}

window.onload = () => {
  document.getElementById('address-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') addAddress(); });
  document.getElementById('base-location-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); setBaseLocation(); } });
  document.getElementById('departure-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') setDepartureAddress(); });
  if (window.pdfjsLib) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  }
};

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function geocodeBasic(address, retryCount = 0) {
  try {
    await sleep(1000);
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1&addressdetails=1&accept-language=pt-BR`;
    const resp = await fetch(url, { headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)', 'Accept': 'application/json' } });
    if (resp.status === 429 && retryCount < 3) {
      await sleep(2000 * (retryCount + 1));
      return geocodeBasic(address, retryCount + 1);
    }
    if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
    const data = await resp.json();
    if (data?.length > 0) {
      return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), display_name: data[0].display_name };
    }
  } catch (e) {
    if (retryCount < 2) {
      await sleep(2000);
      return geocodeBasic(address, retryCount + 1);
    }
  }
  return null;
}

async function processCEP(text) {
  const cepMatch = text.match(/(?:cep\s*:?\s*)?(\d{5})-?(\d{3})(?:\s*,?\s*(\d+))?/i);
  if (!cepMatch) return null;
  const cep = cepMatch[1] + cepMatch[2];
  const numero = cepMatch[3] || '';
  showStatus('Buscando CEP...', 'info');
  try {
    const resp = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
    const data = await resp.json();
    if (data.erro) throw new Error('CEP não encontrado');
    let addressText = data.logradouro || '';
    if (numero) addressText += `, ${numero}`;
    if (data.bairro) addressText += `, ${data.bairro}`;
    addressText += `, ${data.localidade}, ${data.uf}`;
    let coords = await geocodeBasic(`${addressText}, Brasil`);
    if (!coords) coords = await geocodeBasic(`${cep}, Brasil`);
    if (!coords) coords = await geocodeBasic(`${data.localidade}, ${data.uf}, Brasil`);
    if (!coords) throw new Error('Coordenadas não encontradas');
    showStatus('CEP encontrado!', 'success');
    return { success: true, address: addressText, coords, cep: cep };
  } catch (e) {
    showStatus('CEP inválido: ' + e.message, 'warning');
    return { success: false };
  }
}

function haversineDistance(from, to) {
  const R = 6371000;
  const φ1 = from.lat * Math.PI / 180;
  const φ2 = to.lat * Math.PI / 180;
  const Δφ = (to.lat - from.lat) * Math.PI / 180;
  const Δλ = (to.lon - from.lon) * Math.PI / 180;
  const a = Math.sin(Δφ / 2) ** 2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  let d = R * c;
  if (d < 10) d = 10;
  return d;
}

async function calculateRealDistance(from, to) {
  if (!from || !to || typeof from.lat !== 'number' || typeof from.lon !== 'number' || typeof to.lat !== 'number' || typeof to.lon !== 'number') {
    return { distance: Number.POSITIVE_INFINITY, duration: Number.POSITIVE_INFINITY };
  }
  const key = getCacheKey(from.lat, from.lon, to.lat, to.lon);
  if (distanceCache.has(key)) return distanceCache.get(key);
  try {
    const url = `https://routing.openstreetmap.de/routed-car/route/v1/driving/${from.lon},${from.lat};${to.lon},${to.lat}?overview=false`;
    const resp = await fetch(url, { headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' } });
    if (resp.ok) {
      const data = await resp.json();
      if (data?.code === 'Ok' && data.routes?.length > 0) {
        const result = { distance: data.routes[0].distance || haversineDistance(from, to), duration: data.routes[0].duration };
        distanceCache.set(key, result);
        return result;
      }
    }
  } catch (err) {}
  const distance = haversineDistance(from, to);
  const result = { distance, duration: distance / 13.89 };
  distanceCache.set(key, result);
  return result;
}

function parseAddress(text) {
  const parts = text.split(',');
  const rua = parts[0]?.trim() || '';
  const numeroStr = parts[1]?.trim() || '0';
  const numero = parseInt(numeroStr.replace(/\D/g, ''), 10) || 0;
  const cepMatch = text.match(/CEP[:\s]*(\d{5})-?(\d{3})/i);
  const cep = cepMatch ? cepMatch[1] + cepMatch[2] : '00000000';
  return { rua, numero, cep };
}

function calculateGroupCenter(group) {
  const sum = group.reduce((acc, a) => ({ lat: acc.lat + a.coords.lat, lon: acc.lon + a.coords.lon }), { lat: 0, lon: 0 });
  return { lat: sum.lat / group.length, lon: sum.lon / group.length };
}

async function orderSubGroups(currentPos, subGroups) {
  const ordered = [];
  let remaining = [...subGroups];
  while (remaining.length > 0) {
    let closestIdx = 0;
    let closestDist = Infinity;
    for (let i = 0; i < remaining.length; i++) {
      const center = calculateGroupCenter(remaining[i]);
      const { distance } = await calculateRealDistance(currentPos, center);
      if (distance < closestDist) {
        closestDist = distance;
        closestIdx = i;
      }
    }
    const next = remaining.splice(closestIdx, 1)[0];
    ordered.push(...next);
    currentPos = next[next.length - 1].coords;
  }
  return ordered;
}

async function optimizeRouteSmart(start, targets) {
  if (targets.length === 0) return [];
  const validTargets = targets
    .map(t => ({ ...t, parsed: parseAddress(t.text) }))
    .filter(t => t.coords && t.coords.lat && t.coords.lon);

  const groupsByCep = new Map();
  for (const t of validTargets) {
    const key = t.parsed.cep;
    if (!groupsByCep.has(key)) groupsByCep.set(key, []);
    groupsByCep.get(key).push(t);
  }

  let cepGroups = [];
  for (const group of groupsByCep.values()) {
    const subGroupsByStreet = new Map();
    for (const t of group) {
      const key = t.parsed.rua.toLowerCase();
      if (!subGroupsByStreet.has(key)) subGroupsByStreet.set(key, []);
      subGroupsByStreet.get(key).push(t);
    }
    const subGroups = Array.from(subGroupsByStreet.values());
    for (const sg of subGroups) {
      const impares = sg.filter(a => a.parsed.numero % 2 !== 0).sort((a, b) => b.parsed.numero - a.parsed.numero);
      const pares = sg.filter(a => a.parsed.numero % 2 === 0).sort((a, b) => a.parsed.numero - b.parsed.numero);
      sg.splice(0, sg.length, ...impares, ...pares);
    }
    const ordered = await orderSubGroups(start.coords, subGroups);
    cepGroups.push(ordered);
  }

  const route = [];
  let currentPos = start.coords;
  let remaining = [...cepGroups];

  while (remaining.length > 0) {
    let bestIdx = 0;
    let bestDist = Infinity;
    for (let i = 0; i < remaining.length; i++) {
      const center = calculateGroupCenter(remaining[i]);
      const { distance } = await calculateRealDistance(currentPos, center);
      if (distance < bestDist) {
        bestDist = distance;
        bestIdx = i;
      }
    }
    const selected = remaining.splice(bestIdx, 1)[0];
    let bestStart = 0;
    let minDist = Infinity;
    for (let j = 0; j < selected.length; j++) {
      const { distance } = await calculateRealDistance(currentPos, selected[j].coords);
      if (distance < minDist) {
        minDist = distance;
        bestStart = j;
      }
    }
    const rotated = [...selected.slice(bestStart), ...selected.slice(0, bestStart)];
    if (bestStart > selected.length / 2) rotated.reverse();
    route.push(...rotated);
    currentPos = rotated[rotated.length - 1].coords;
  }
  return route;
}

async function addAddress() {
  if (!userLocation) return showStatus('Defina a localização base primeiro.', 'warning');
  const input = document.getElementById('address-input');
  let text = input.value.trim();
  if (!text) return;
  showStatus('Buscando endereço...', 'info');
  const cepResult = await processCEP(text);
  if (cepResult?.success) {
    const numMatch = cepResult.address.match(/, (\d+)/);
    const houseNumber = numMatch ? parseInt(numMatch[1]) : 0;
    addresses.push({ id: Date.now(), text: cepResult.address, coords: cepResult.coords, cep: cepResult.cep, number: houseNumber, completed: false });
    input.value = '';
    renderAddressList();
    document.getElementById('optimize-btn').style.display = 'block';
    showStatus('Endereço adicionado!', 'success');
    return;
  }
  const fullQuery = `${text}, ${userLocation.city}, ${userLocation.state}, Brasil`;
  const coords = await geocodeBasic(fullQuery);
  if (coords) {
    addresses.push({ id: Date.now(), text: text, coords: coords, completed: false });
    input.value = '';
    renderAddressList();
    document.getElementById('optimize-btn').style.display = 'block';
    showStatus('Endereço adicionado!', 'success');
  } else {
    showStatus('Buscando sugestões...', 'info');
    await searchAndSelectAddress(text);
  }
}

async function searchAndSelectAddress(query) {
  const suggestionsContainer = document.getElementById('suggestions-container');
  suggestionsContainer.style.display = 'block';
  suggestionsContainer.innerHTML = '<div class="status-bar status-info">Buscando endereços...</div>';
  try {
    const cityState = `${userLocation.city}, ${userLocation.state}, Brasil`;
    const fullQuery = `${query}, ${cityState}`;
    const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullQuery)}&limit=5&addressdetails=1&accept-language=pt-BR`, {
      headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' }
    });
    const results = await resp.json();
    if (!results || results.length === 0) {
      suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Nenhum endereço encontrado.</div>';
      setTimeout(() => suggestionsContainer.style.display = 'none', 4000);
      return;
    }
    let html = '<h4 style="margin:10px 0;color:#333;">Escolha o endereço correto:</h4>';
    results.forEach((res, i) => {
      const addr = res.address || {};
      const display = `${addr.road || ''}${addr.house_number ? ', ' + addr.house_number : ''} – ${addr.suburb || addr.neighbourhood || ''}`;
      html += `<div class="address-item suggestion-item" onclick="selectSuggestion(${i})"><div>${display}</div><small>${addr.city || userLocation.city}</small></div>`;
    });
    suggestionsContainer.innerHTML = html;
    window.pendingSuggestions = results;
  } catch (e) {
    suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Erro na busca.</div>';
  }
}

function selectSuggestion(index) {
  const result = window.pendingSuggestions?.[index];
  if (!result) return;
  const addr = result.address || {};
  let displayText = `${addr.road || ''}${addr.house_number ? ', ' + addr.house_number : ''}, ${addr.suburb || ''}, ${addr.city || ''}`;
  const cepMatch = result.display_name.match(/\d{5}-?\d{3}/);
  const extractedCep = cepMatch ? cepMatch[0].replace("-", "") : "99999999";
  const numMatch = displayText.match(/, (\d+)/);
  const houseNumber = numMatch ? parseInt(numMatch[1]) : 0;
  addresses.push({ id: Date.now(), text: displayText, coords: { lat: parseFloat(result.lat), lon: parseFloat(result.lon) }, cep: extractedCep, number: houseNumber, completed: false });
  document.getElementById('address-input').value = '';
  renderAddressList();
  document.getElementById('optimize-btn').style.display = 'block';
  document.getElementById('suggestions-container').style.display = 'none';
  showStatus('Endereço adicionado!', 'success');
}

function setBaseLocation() {
  const input = document.getElementById('base-location-input');
  const text = input.value.trim();
  if (!text) return showStatus('Informe cidade e estado.', 'warning');
  geocodeBaseLocation(text);
}

async function geocodeBaseLocation(locationText) {
  showStatus('Verificando localização base...', 'info');
  try {
    const data = await (await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationText + ', Brasil')}&limit=1&addressdetails=1&accept-language=pt-BR`, {
      headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' }
    })).json();
    if (!data?.length) throw new Error('Nenhum resultado encontrado.');
    const addr = data[0].address || {};
    const city = addr.city || addr.town || addr.municipality || addr.village || '';
    const state = addr.state || '';
    if (!city) throw new Error('Cidade não identificada.');
    userLocation = { city, state };
    document.getElementById('base-location-display').textContent = `Localização base: ${city}${state ? ', ' + state : ''}.`;
    document.getElementById('departure-section').style.display = 'block';
    showStatus('Localização base definida!', 'success');
  } catch (error) {
    showStatus(`${error.message}`, 'warning');
    userLocation = null;
  }
}

async function setDepartureAddress() {
  const input = document.getElementById('departure-input');
  const text = input.value.trim();
  if (!text) return showStatus('Informe o ponto de partida.', 'warning');
  const cepResult = await processCEP(text);
  if (cepResult?.success) {
    departure = { text: cepResult.address, coords: cepResult.coords };
    document.getElementById('departure-display').textContent = departure.text;
    input.value = '';
    showStatus('Partida definida!', 'success');
    return;
  }
  await searchAndSelectDeparture(text);
}

async function setDepartureCurrentLocation() {
  if (!navigator.geolocation) return showStatus('Geolocalização não suportada.', 'warning');
  showStatus('Obtendo sua localização...', 'info');
  navigator.geolocation.getCurrentPosition(async (pos) => {
    const { latitude, longitude } = pos.coords;
    departure = { text: 'Minha localização atual', coords: { lat: latitude, lon: longitude } };
    document.getElementById('departure-display').textContent = 'Minha localização atual';
    showStatus('Partida definida!', 'success');
  }, (err) => showStatus('Erro na localização: ' + err.message, 'warning'), { enableHighAccuracy: true });
}

async function searchAndSelectDeparture(query) {
  const suggestionsContainer = document.getElementById('departure-suggestions');
  suggestionsContainer.style.display = 'block';
  suggestionsContainer.innerHTML = '<div class="status-bar status-info">Buscando endereços...</div>';
  try {
    const cityState = `${userLocation.city}, ${userLocation.state}, Brasil`;
    const fullQuery = `${query}, ${cityState}`;
    const resp = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fullQuery)}&limit=5&addressdetails=1&accept-language=pt-BR`, {
      headers: { 'User-Agent': 'RouteOptimizerApp/1.0 (entregador.gratuito.app)' }
    });
    const results = await resp.json();
    if (!results || results.length === 0) {
      suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Nenhum endereço encontrado.</div>';
      return;
    }
    let html = '<h4 style="margin:10px 0;color:#333;">Escolha o ponto de partida:</h4>';
    results.forEach((res, i) => {
      html += `<div class="address-item suggestion-item" onclick="selectDepartureSuggestion(${i})"><div>${res.display_name}</div></div>`;
    });
    suggestionsContainer.innerHTML = html;
    window.pendingDepartureSuggestions = results;
  } catch (e) {
    suggestionsContainer.innerHTML = '<div class="status-bar status-warning">Erro na busca.</div>';
  }
}

function selectDepartureSuggestion(index) {
  const result = window.pendingDepartureSuggestions?.[index];
  if (!result) return;
  departure = { text: result.display_name, coords: { lat: parseFloat(result.lat), lon: parseFloat(result.lon) } };
  document.getElementById('departure-input').value = '';
  document.getElementById('departure-display').textContent = departure.text;
  document.getElementById('departure-suggestions').style.display = 'none';
  showStatus('Partida definida!', 'success');
}

async function geocodeAddressFull(address) {
  let full = address + ', Brasil';
  if (userLocation) full = `${address}, ${userLocation.city}${userLocation.state ? ', ' + userLocation.state : ''}, Brasil`;
  let coords = await geocodeBasic(full);
  if (coords) return coords;
  if (userLocation) {
    const fallback = `${userLocation.city}, ${userLocation.state}, Brasil`;
    coords = await geocodeBasic(fallback);
  }
  return coords;
}

async function optimizeRoute() {
  if (!departure || addresses.length === 0) return showStatus('Defina partida e destinos.', 'warning');
  const btn = document.getElementById('optimize-btn');
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Otimizando...';
  try {
    const destinosValidos = [];
    const BATCH_SIZE = 3;
    for (let i = 0; i < addresses.length; i += BATCH_SIZE) {
      const batch = addresses.slice(i, i + BATCH_SIZE);
      const promises = batch.map(async (addr, idx) => {
        const globalIdx = i + idx + 1;
        showStatus(`Localizando endereço ${globalIdx} de ${addresses.length}...`, 'info');
        if (!addr.coords || !addr.coords.lat || !addr.coords.lon) {
          const coords = await geocodeAddressFull(addr.text);
          if (coords) {
            addr.coords = coords;
            return addr;
          }
          return null;
        }
        return addr;
      });
      const results = await Promise.all(promises);
      destinosValidos.push(...results.filter(r => r !== null));
      if (i + BATCH_SIZE < addresses.length) await sleep(1000);
    }
    if (destinosValidos.length === 0) return showStatus('Nenhum destino válido.', 'warning');
    showStatus('Calculando melhor rota...', 'info');
    const optimized = await optimizeRouteSmart(departure, destinosValidos);
    optimizedRoute = [{ ...departure, completed: true }, ...optimized];
    activeIndex = 1;
    document.getElementById('add-section').style.display = 'none';
    document.getElementById('route-section').style.display = 'block';
    btn.style.display = 'none';
    await renderRoute();
    showStatus('Rota otimizada!', 'success');
  } catch (e) {
    console.error(e);
    showStatus('Erro ao otimizar.', 'warning');
  } finally {
    btn.disabled = false;
    btn.innerHTML = 'Otimizar Rota';
  }
}

function renderAddressList() {
  const list = document.getElementById('address-list');
  if (addresses.length === 0) { list.innerHTML = ''; return; }
  let html = '';
  addresses.forEach((addr, i) => {
    html += `<div class="address-item">
      <div class="address-number">${i + 1}</div>
      <div class="address-text">${addr.text}</div>
      <button class="btn-delete" onclick="editAddress(${addr.id})" title="Editar">Edit</button>
      <button class="btn-delete" onclick="deleteAddress(${addr.id})" title="Excluir">Delete</button>
    </div>`;
  });
  list.innerHTML = html;
}

function editAddress(id) {
  const addr = addresses.find(a => a.id === id);
  if (!addr) return;
  const newText = prompt('Editar endereço:', addr.text);
  if (newText === null || newText.trim() === '') return;
  (async () => {
    showStatus('Atualizando...', 'info');
    const coords = await geocodeBasic(newText.trim());
    if (coords) {
      addr.text = newText.trim();
      addr.coords = coords;
      renderAddressList();
      showStatus('Atualizado!', 'success');
    } else {
      showStatus('Não localizado.', 'warning');
    }
  })();
}

async function renderRoute() {
  const list = document.getElementById('route-list');
  let html = '';
  for (let i = 0; i < optimizedRoute.length; i++) {
    const a = optimizedRoute[i];
    const ativo = i === activeIndex && !a.completed;
    const concluido = a.completed;
    let distInfo = '';
    if (i > 0) {
      const { distance, duration } = await calculateRealDistance(optimizedRoute[i - 1].coords, a.coords);
      distInfo = `<small style="color:#0056b3;">${(distance / 1000).toFixed(1)}km · ${Math.round(duration / 60)}min</small>`;
    }
    html += `<div class="route-item ${ativo ? 'active' : ''} ${concluido ? 'completed' : ''}">
      <div class="route-header">
        <div class="route-number ${ativo ? 'active' : ''} ${concluido ? 'completed' : ''}">${concluido ? 'Check' : i === 0 ? 'P' : i}</div>
        <div class="route-text"><strong>${i === 0 ? 'Ponto de Partida' : a.text}</strong>${distInfo}</div>
      </div>
      ${ativo && !concluido ? `<div class="route-buttons">
          <button class="btn btn-maps btn-small" onclick="openMaps(${i}, 'google')">Maps</button>
          <button class="btn btn-waze btn-small" onclick="openMaps(${i}, 'waze')">Waze</button>
          <button class="btn btn-complete btn-small" onclick="markCompleted(${i})">Check</button>
        </div>` : ''}
    </div>`;
  }
  list.innerHTML = html;
  updateProgress();
}

function openMaps(i, app) {
  const a = optimizedRoute[i];
  const { lat, lon } = a.coords || {};
  if (app === 'google') window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lon}`, '_blank');
  else if (app === 'waze') window.open(`https://www.waze.com/ul?ll=${lat},${lon}&navigate=yes`, '_blank');
}

function markCompleted(i) {
  optimizedRoute[i].completed = true;
  if (i < optimizedRoute.length - 1) activeIndex = i + 1;
  renderRoute();
}

function updateProgress() {
  const concluidos = optimizedRoute.slice(1).filter(a => a.completed).length;
  const total = optimizedRoute.length - 1;
  document.getElementById('progress-bar').innerHTML = `<strong>${concluidos} de ${total}</strong> paradas concluídas`;
}

function resetRoute() {
  optimizedRoute = []; activeIndex = 0; addresses = []; departure = null; distanceCache.clear();
  document.getElementById('departure-section').style.display = 'none';
  document.getElementById('add-section').style.display = 'block';
  document.getElementById('route-section').style.display = 'none';
  renderAddressList();
  document.getElementById('optimize-btn').style.display = 'none';
  document.getElementById('status-container').innerHTML = '';
  document.getElementById('base-location-input').value = '';
  document.getElementById('base-location-display').textContent = 'Nenhuma localização base definida.';
  document.getElementById('departure-input').value = '';
  document.getElementById('departure-display').textContent = 'Nenhum ponto de partida definido.';
  document.getElementById('address-input').value = '';
  stopCamera();
}

function requestVoicePermissionAndStart() {
  if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) return showStatus('Voz não suportada.', 'warning');
  if (!userLocation) return showStatus('Defina localização base.', 'warning');
  startVoice();
}

function startVoice() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  const recognition = new SpeechRecognition();
  recognition.lang = 'pt-BR';
  const btn = document.getElementById('voice-btn');
  btn.disabled = true;
  recognition.onstart = () => { btn.classList.add('listening'); btn.textContent = 'Ouvindo...'; showStatus('Fale o endereço...', 'info'); };
  recognition.onend = () => { btn.classList.remove('listening'); btn.textContent = 'Voz'; btn.disabled = false; };
  recognition.onresult = (e) => { document.getElementById('address-input').value = e.results[0][0].transcript.trim(); addAddress(); };
  recognition.onerror = (e) => { showStatus('Erro: ' + e.error, 'warning'); };
  recognition.start();
}

async function requestCameraPermissionAndStart(mode) {
  if (!userLocation) return showStatus('Defina localização base.', 'warning');
  isPhotoMode = mode === 'photo';
  scannerType = isPhotoMode ? null : mode;
  let buttonsHTML = isPhotoMode ? `<button class="btn btn-capture" onclick="captureImage()">Capturar Foto</button>` : `<button class="btn btn-capture" onclick="captureForScan()">Capturar Frame</button>`;
  buttonsHTML += `<button class="btn btn-cancel" onclick="stopCamera()">Cancelar</button>`;
  document.getElementById('camera-buttons').innerHTML = buttonsHTML;
  await startCamera();
}

let scanInterval = null;
async function startCamera() {
  try {
    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } } });
    const video = document.getElementById('camera-video');
    video.srcObject = cameraStream;
    document.getElementById('camera-container').style.display = 'block';
    if (scanInterval) clearInterval(scanInterval);
    if (!isPhotoMode && scannerType) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      scanInterval = setInterval(() => {
        if (video.readyState === video.HAVE_ENOUGH_DATA && video.videoWidth > 0) {
          canvas.width = video.videoWidth; canvas.height = video.videoHeight;
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          if (scannerType === 'qr') {
            const code = jsQR(imageData.data, canvas.width, canvas.height);
            if (code) { handleScannedCode(code.data); clearInterval(scanInterval); stopCamera(); }
          }
        }
      }, 500);
    }
  } catch (e) { showStatus('Erro na câmera.', 'warning'); }
}

async function captureForScan() {
  const video = document.getElementById('camera-video');
  if (video.videoWidth === 0) return;
  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  if (scannerType === 'qr') {
    const code = jsQR(imageData.data, canvas.width, canvas.height);
    if (code) { handleScannedCode(code.data); stopCamera(); return; }
  } else if (scannerType === 'barcode') {
    Quagga.decodeSingle({ decoder: { readers: ['code_128_reader', 'ean_reader', 'code_39_reader'] }, locate: true, src: canvas.toDataURL('image/png') }, (result) => {
      if (result?.codeResult) { handleScannedCode(result.codeResult.code); stopCamera(); }
      else { showStatus('Não detectado.', 'warning'); }
    });
    return;
  }
  showStatus('Não detectado.', 'warning');
}

function stopCamera() {
  if (scanInterval) clearInterval(scanInterval);
  if (cameraStream) cameraStream.getTracks().forEach(t => t.stop());
  document.getElementById('camera-container').style.display = 'none';
}

async function captureImage() {
  const video = document.getElementById('camera-video');
  const canvas = document.createElement('canvas');
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  canvas.getContext('2d').drawImage(video, 0, 0);
  showStatus('Extraindo texto...', 'info');
  try {
    const result = await Tesseract.recognize(canvas.toDataURL('image/png'), 'por');
    document.getElementById('address-input').value = result.data.text.trim().replace(/\n/g, ' ');
    addAddress();
  } catch (err) { showStatus('Erro no OCR.', 'warning'); }
  stopCamera();
}

function handleScannedCode(code) { document.getElementById('address-input').value = code; addAddress(); }
function addUserLocationManually() { showStatus('Use o botão em “Ponto de Partida”.', 'info'); }
function showStatus(message, type = 'info') {
  const c = document.getElementById('status-container');
  const cls = type === 'success' ? 'status-success' : type === 'warning' ? 'status-warning' : 'status-info';
  c.innerHTML = `<div class="status-bar ${cls}">${message}</div>`;
  if (type !== 'warning') setTimeout(() => c.innerHTML = '', 5000);
}
function uploadPdf() { document.getElementById('pdf-upload').click(); }

async function processPdf(e) {
  const file = e.target.files[0];
  if (!file) return;
  showStatus('Lendo PDF...', 'info');
  try {
    const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
    const numPages = pdf.numPages;
    let allMatches = [];
    for (let i = 1; i <= numPages; i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();
      const pageText = textContent.items.map(item => item.str).join(' ');
      const pattern = /Endereço:\s*(.+?),\s*(\d{1,6})\s+CEP:\s*(\d{5})-?(\d{3})/gi;
      const matches = [...pageText.matchAll(pattern)];
      for (const m of matches) {
        const rua = m[1].trim();
        const numero = m[2].trim();
        const cep = m[3] + m[4];
        const addrText = `${rua}, ${numero}, CEP: ${m[3]}-${m[4]}`;
        allMatches.push({ text: addrText, cep: cep, numero: numero });
      }
    }
    if (allMatches.length === 0) {
      showStatus('Nenhum endereço encontrado no formato esperado.', 'warning');
      return;
    }
    for (const match of allMatches) {
      addresses.push({
        id: Date.now() + Math.random(),
        text: match.text,
        coords: null,
        cep: match.cep,
        number: parseInt(match.numero) || 0,
        completed: false
      });
    }
    renderAddressList();
    document.getElementById('optimize-btn').style.display = 'block';
    showStatus(`${allMatches.length} endereços adicionados! Toque em "Otimizar Rota" para continuar.`, 'success');
  } catch (err) {
    showStatus('Erro ao processar o PDF.', 'warning');
  } finally {
    e.target.value = '';
  }
}

function deleteAddress(id) {
  addresses = addresses.filter(a => a.id !== id);
  renderAddressList();
  if (addresses.length === 0) document.getElementById('optimize-btn').style.display = 'none';
}
</script>
</body>
</html>
